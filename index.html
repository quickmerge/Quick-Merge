<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quick Merge – Merge, Compress & Convert Files Instantly</title>
  <meta name="description" content="Quick Merge offers fast, secure file processing tools including PDF merging, splitting, compression, image conversion, and QR code generation - all processed locally in your browser.">
  <meta name="keywords" content="PDF merge, PDF split, compress PDF, image to PDF, QR code generator, file converter, online tools, privacy-focused tools">
  <meta name="author" content="Quick Merge">
  <meta name="robots" content="index, follow">
  <meta property="og:title" content="Quick Merge - File Processing Tools">
  <meta property="og:description" content="Merge, compress and convert files instantly with our privacy-focused browser tools">
  <meta property="og:type" content="website">
  <!-- Required Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/docx/7.8.2/docx.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(to right, #0f0f10, #111215);
      color: #f0f0f0;
      line-height: 1.6;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    a {
      text-decoration: none;
      color: inherit;
    }

    /* Header */
    header {
      background: rgba(15, 15, 16, 0.95);
      position: sticky;
      top: 0;
      z-index: 1000;
      backdrop-filter: blur(10px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }

    .nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      max-width: 1200px;
      margin: auto;
      padding: 1rem 2rem;
    }

    .nav h1 {
      font-size: 1.5rem;
      font-weight: 700;
      background: linear-gradient(90deg, #00f6ff, #6c5dd3);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .nav .nav-links {
      display: flex;
      gap: 1.5rem;
    }

    .nav .nav-links a {
      font-size: 1rem;
      color: #ccc;
      transition: color 0.2s;
    }

    .nav .nav-links a:hover {
      color: #fff;
    }

    .container {
      max-width: 1200px;
      margin: auto;
      padding: 2rem;
      flex: 1;
    }

    .hero {
      text-align: center;
      padding: 5rem 2rem 3rem;
    }

    .hero h2 {
      font-size: 2.8rem;
      background: linear-gradient(90deg, #00f6ff, #6c5dd3);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .hero p {
      color: #aaa;
      margin-top: 1rem;
      font-size: 1.2rem;
    }

    .cta {
      margin-top: 2rem;
    }

    .cta button {
      background: #6c5dd3;
      color: white;
      padding: 0.8rem 1.6rem;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      cursor: pointer;
      transition: 0.3s ease;
    }

    .cta button:hover {
      background: #5842c3;
    }

    /* Tool Cards Grid */
    .tools {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 2rem;
      margin-top: 4rem;
    }

    .tool-card {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(14px);
      border-radius: 14px;
      padding: 2rem;
      border: 1px solid rgba(255, 255, 255, 0.06);
      box-shadow: 0 0 20px rgba(108, 93, 211, 0.08);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .tool-card:hover {
      transform: translateY(-6px);
      box-shadow: 0 0 28px rgba(108, 93, 211, 0.25);
    }

    .tool-card h3 {
      font-size: 1.3rem;
      color: #fff;
      margin-bottom: 0.5rem;
    }

    .tool-card p {
      color: #bbb;
      font-size: 0.95rem;
    }

    /* Tool Content */
    .tool-content {
      display: none;
      margin-top: 1.5rem;
    }

    .tool-card.active {
      padding-bottom: 2.5rem;
    }

    .tool-card.active .tool-content {
      display: block;
    }

    .file-input {
      width: 100%;
      margin-bottom: 1rem;
    }

    .file-input label {
      display: block;
      margin-bottom: 0.5rem;
      color: #ddd;
      font-size: 0.9rem;
    }

    .file-input input[type="file"] {
      width: 100%;
      padding: 0.5rem;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      color: #fff;
      display: none;
    }

    .drag-drop-area {
      width: 100%;
      padding: 2rem;
      border: 2px dashed rgba(255,255,255,0.3);
      border-radius: 8px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
      margin-bottom: 1rem;
    }

    .drag-drop-area:hover {
      border-color: #6c5dd3;
      background: rgba(108, 93, 211, 0.1);
    }

    .drag-drop-area.active {
      border-color: #6c5dd3;
      background: rgba(108, 93, 211, 0.2);
    }

    .drag-drop-area p {
      margin-bottom: 0.5rem;
    }

    .drag-drop-area .small {
      font-size: 0.8rem;
      color: #aaa;
    }

    .file-list {
      margin-top: 1rem;
      max-height: 150px;
      overflow-y: auto;
    }

    .file-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem;
      background: rgba(255,255,255,0.05);
      border-radius: 4px;
      margin-bottom: 0.3rem;
    }

    .file-item-name {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 70%;
    }

    .file-item-size {
      font-size: 0.8rem;
      color: #aaa;
    }

    .file-item-remove {
      color: #ff6b6b;
      cursor: pointer;
      margin-left: 0.5rem;
    }

    .tool-btn {
      background: #6c5dd3;
      color: white;
      padding: 0.6rem 1.2rem;
      border: none;
      border-radius: 6px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: 0.3s ease;
      margin-top: 0.5rem;
      width: 100%;
    }

    .tool-btn:hover {
      background: #5842c3;
    }

    .tool-btn.secondary {
      background: transparent;
      border: 1px solid #6c5dd3;
      margin-top: 0.5rem;
    }

    .tool-btn.secondary:hover {
      background: rgba(108, 93, 211, 0.1);
    }

    .tool-btn:disabled {
      background: #555;
      cursor: not-allowed;
      opacity: 0.7;
    }

    .options {
      margin: 1rem 0;
    }

    .option-group {
      margin-bottom: 1rem;
    }

    .option-group label {
      display: block;
      margin-bottom: 0.3rem;
      color: #ddd;
      font-size: 0.9rem;
    }

    .option-group input[type="text"],
    .option-group input[type="number"],
    .option-group select,
    .option-group textarea {
      width: 100%;
      padding: 0.5rem;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      color: #fff;
    }

    .option-group input[type="range"] {
      width: 100%;
    }

    .preview-container {
      margin-top: 1rem;
      text-align: center;
    }

    .preview-container img {
      max-width: 100%;
      max-height: 200px;
      border-radius: 6px;
    }

    .qr-code-container {
      display: flex;
      justify-content: center;
      margin: 1rem 0;
    }

    /* Status messages */
    .status-message {
      margin-top: 1rem;
      padding: 0.5rem;
      border-radius: 4px;
      font-size: 0.9rem;
      text-align: center;
    }

    .status-message.success {
      background: rgba(46, 204, 113, 0.2);
      color: #2ecc71;
    }

    .status-message.error {
      background: rgba(231, 76, 60, 0.2);
      color: #e74c3c;
    }

    /* About, Contact, Privacy pages styles */
    .content-page {
      background: linear-gradient(to right, #0f0f10, #111215);
      color: #f0f0f0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .content-container {
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem;
      flex: 1;
    }

    .content-page h1 {
      font-size: 2.5rem;
      margin-bottom: 1.5rem;
      background: linear-gradient(90deg, #00f6ff, #6c5dd3);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-align: center;
      padding-bottom: 0.5rem;
    }

    .content-page h2 {
      font-size: 1.8rem;
      margin: 2rem 0 1rem;
      color: #fff;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      padding-bottom: 0.5rem;
    }

    .content-page h3 {
      font-size: 1.3rem;
      margin: 1.5rem 0 1rem;
      color: #ddd;
    }

    .content-page p {
      margin-bottom: 1.2rem;
      color: #bbb;
      line-height: 1.7;
      font-size: 1.05rem;
    }

    .content-page ul, .content-page ol {
      margin-bottom: 1.5rem;
      padding-left: 2rem;
    }

    .content-page li {
      margin-bottom: 0.7rem;
      color: #bbb;
      line-height: 1.6;
    }

    .feature-list, .contact-box, .policy-section {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(14px);
      border-radius: 14px;
      padding: 1.8rem;
      margin: 2rem 0;
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 0 20px rgba(108, 93, 211, 0.08);
    }

    .feature-item {
      margin-bottom: 1rem;
      color: #ddd;
      padding-left: 1rem;
      border-left: 3px solid #6c5dd3;
    }

    .contact-method {
      margin-bottom: 1.5rem;
      padding: 1rem;
      background: rgba(108, 93, 211, 0.1);
      border-radius: 8px;
    }

    .contact-method h3 {
      color: #6c5dd3;
      margin-bottom: 0.5rem;
    }

    .content-page a {
      color: #6c5dd3;
      transition: color 0.2s;
      text-decoration: underline;
    }

    .content-page a:hover {
      color: #00f6ff;
    }

    .update-date {
      font-style: italic;
      color: #aaa;
      margin-bottom: 1.5rem;
      display: block;
      text-align: center;
      font-size: 0.95rem;
    }

    .privacy-notice {
      text-align: center;
      margin: 3rem 0;
      padding: 2rem;
      background: rgba(108, 93, 211, 0.1);
      border-radius: 14px;
      border: 1px solid rgba(108, 93, 211, 0.2);
    }

    .privacy-notice h2 {
      font-size: 2rem;
      background: linear-gradient(90deg, #00f6ff, #6c5dd3);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      border: none;
      margin-bottom: 1rem;
    }

    .privacy-notice p {
      font-size: 1.1rem;
      max-width: 700px;
      margin: 0 auto;
    }

    /* Footer */
    footer {
      margin-top: auto;
      padding: 2rem;
      text-align: center;
      font-size: 0.9rem;
      color: #666;
      border-top: 1px solid #222;
    }

    /* Fade In Animation */
    .fade-in {
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.8s ease;
    }

    .fade-in.visible {
      opacity: 1;
      transform: translateY(0);
    }

    /* Loading spinner */
    .spinner {
      display: none;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 1s ease-in-out infinite;
      margin: 0 auto;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Hide content sections by default */
    .content-section {
      display: none;
    }

    .active-section {
      display: block;
    }

    @media (max-width: 768px) {
      .hero h2 {
        font-size: 2rem;
      }

      .content-page h1 {
        font-size: 2rem;
      }

      .content-page h2 {
        font-size: 1.5rem;
      }

      .nav {
        flex-direction: column;
        align-items: flex-start;
      }

      .nav .nav-links {
        margin-top: 0.5rem;
        flex-wrap: wrap;
      }

      .content-container, .container {
        padding: 1.5rem;
      }
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header>
    <div class="nav">
      <h1>Quick Merge</h1>
      <div class="nav-links">
        <a href="#" onclick="showSection('home')">Home</a>
        <a href="#" onclick="showSection('about')">About</a>
        <a href="#" onclick="showSection('contact')">Contact</a>
        <a href="#" onclick="showSection('privacy')">Privacy</a>
      </div>
    </div>
  </header>

  <!-- Home Section -->
  <section id="home" class="content-section active-section">
    <!-- Hero -->
    <section class="hero">
      <div class="container">
        <h2>Merge, Compress & Convert Files Instantly</h2>
        <p>All tools run locally in your browser — fast, private, and secure.</p>
        <div class="cta">
          <button onclick="document.getElementById('tools').scrollIntoView({ behavior: 'smooth' })">Explore Tools</button>
        </div>
      </div>
    </section>

    <!-- Tools -->
    <section id="tools" class="container">
      <div class="tools">
        <!-- Merge PDF -->
        <div class="tool-card fade-in" id="merge-pdf-card">
          <h3>Merge PDF</h3>
          <p>Combine multiple PDF files into one seamless document.</p>
          <button class="tool-btn" onclick="toggleTool('merge-pdf')">Use Tool</button>
          <div class="tool-content" id="merge-pdf">
            <div class="file-input">
              <label>Select PDF files to merge:</label>
              <div class="drag-drop-area" id="merge-pdf-drop-area">
                <p>Drag & drop PDF files here</p>
                <p class="small">or click to browse</p>
              </div>
              <input type="file" id="merge-pdf-files" accept=".pdf" multiple>
              <div class="file-list" id="merge-pdf-file-list"></div>
            </div>
            <button class="tool-btn" id="merge-pdf-btn" onclick="mergePDFs()">Merge PDFs</button>
            <div class="spinner" id="merge-pdf-spinner"></div>
            <div class="status-message" id="merge-pdf-status"></div>
          </div>
        </div>

        <!-- Split PDF -->
        <div class="tool-card fade-in" id="split-pdf-card">
          <h3>Split PDF</h3>
          <p>Extract selected pages or split PDF into multiple parts.</p>
          <button class="tool-btn" onclick="toggleTool('split-pdf')">Use Tool</button>
          <div class="tool-content" id="split-pdf">
            <div class="file-input">
              <label>Select PDF file to split:</label>
              <div class="drag-drop-area" id="split-pdf-drop-area">
                <p>Drag & drop a PDF file here</p>
                <p class="small">or click to browse</p>
              </div>
              <input type="file" id="split-pdf-file" accept=".pdf">
              <div class="file-list" id="split-pdf-file-list"></div>
            </div>
            <div class="options">
              <div class="option-group">
                <label for="split-pages">Pages to extract (e.g., 1-3,5,7-9):</label>
                <input type="text" id="split-pages" placeholder="1-3,5,7-9">
              </div>
            </div>
            <button class="tool-btn" id="split-pdf-btn" onclick="splitPDF()">Split PDF</button>
            <div class="spinner" id="split-pdf-spinner"></div>
            <div class="status-message" id="split-pdf-status"></div>
          </div>
        </div>

        <!-- Compress PDF -->
        <div class="tool-card fade-in" id="compress-pdf-card">
          <h3>Compress PDF</h3>
          <p>Reduce PDF file size without losing quality or formatting.</p>
          <button class="tool-btn" onclick="toggleTool('compress-pdf')">Use Tool</button>
          <div class="tool-content" id="compress-pdf">
            <div class="file-input">
              <label>Select PDF file to compress:</label>
              <div class="drag-drop-area" id="compress-pdf-drop-area">
                <p>Drag & drop a PDF file here</p>
                <p class="small">or click to browse</p>
              </div>
              <input type="file" id="compress-pdf-file" accept=".pdf">
              <div class="file-list" id="compress-pdf-file-list"></div>
            </div>
            <div class="options">
              <div class="option-group">
                <label for="compression-level">Compression level:</label>
                <select id="compression-level">
                  <option value="low">Low (better quality)</option>
                  <option value="medium" selected>Medium (balanced)</option>
                  <option value="high">High (smaller file)</option>
                  <option value="extreme">Extreme (maximum compression)</option>
                </select>
              </div>
            </div>
            <button class="tool-btn" id="compress-pdf-btn" onclick="compressPDF()">Compress PDF</button>
            <div class="spinner" id="compress-pdf-spinner"></div>
            <div class="status-message" id="compress-pdf-status"></div>
          </div>
        </div>

        <!-- Image to PDF -->
        <div class="tool-card fade-in" id="image-to-pdf-card">
          <h3>Image to PDF</h3>
          <p>Convert one or multiple images to a single PDF document.</p>
          <button class="tool-btn" onclick="toggleTool('image-to-pdf')">Use Tool</button>
          <div class="tool-content" id="image-to-pdf">
            <div class="file-input">
              <label>Select image(s) to convert:</label>
              <div class="drag-drop-area" id="image-to-pdf-drop-area">
                <p>Drag & drop images here</p>
                <p class="small">or click to browse</p>
              </div>
              <input type="file" id="image-to-pdf-files" accept="image/*" multiple>
              <div class="file-list" id="image-to-pdf-file-list"></div>
            </div>
            <div class="options">
              <div class="option-group">
                <label for="pdf-layout">Page Layout:</label>
                <select id="pdf-layout">
                  <option value="portrait">Portrait</option>
                  <option value="landscape">Landscape</option>
                  <option value="auto">Auto (match image orientation)</option>
                </select>
              </div>
              <div class="option-group">
                <label for="pdf-margin">Margin (mm):</label>
                <input type="number" id="pdf-margin" min="0" max="50" value="5">
              </div>
            </div>
            <button class="tool-btn" id="image-to-pdf-btn" onclick="convertImagesToPDF()">Convert to PDF</button>
            <div class="spinner" id="image-to-pdf-spinner"></div>
            <div class="status-message" id="image-to-pdf-status"></div>
          </div>
        </div>

        <!-- Text to Word/PDF -->
        <div class="tool-card fade-in" id="text-converter-card">
          <h3>Text to Word/PDF</h3>
          <p>Convert plain text to professional Word or PDF documents.</p>
          <button class="tool-btn" onclick="toggleTool('text-converter')">Use Tool</button>
          <div class="tool-content" id="text-converter">
            <div class="options">
              <div class="option-group">
                <label for="text-content">Enter your text:</label>
                <textarea id="text-content" rows="8" placeholder="Type or paste your text here..."></textarea>
              </div>
              <div class="option-group">
                <label for="text-filename">File name (without extension):</label>
                <input type="text" id="text-filename" placeholder="document">
              </div>
              <div class="option-group">
                <label for="text-format">Output format:</label>
                <select id="text-format">
                  <option value="docx">Word Document (.docx)</option>
                  <option value="pdf">PDF Document (.pdf)</option>
                </select>
              </div>
            </div>
            <button class="tool-btn" id="text-convert-btn" onclick="convertTextToDocument()">Convert Text</button>
            <div class="spinner" id="text-converter-spinner"></div>
            <div class="status-message" id="text-converter-status"></div>
          </div>
        </div>

        <!-- Compress Images -->
        <div class="tool-card fade-in" id="compress-image-card">
          <h3>Compress Images</h3>
          <p>Smartly compress JPEG, PNG, or WebP images with no quality loss.</p>
          <button class="tool-btn" onclick="toggleTool('compress-image')">Use Tool</button>
          <div class="tool-content" id="compress-image">
            <div class="file-input">
              <label>Select image(s) to compress:</label>
              <div class="drag-drop-area" id="compress-image-drop-area">
                <p>Drag & drop images here</p>
                <p class="small">or click to browse</p>
              </div>
              <input type="file" id="compress-image-files" accept="image/*" multiple>
              <div class="file-list" id="compress-image-file-list"></div>
            </div>
            <div class="options">
              <div class="option-group">
                <label for="image-quality">Quality (0-100):</label>
                <input type="range" id="image-quality" min="0" max="100" value="80">
                <span id="quality-value">80%</span>
              </div>
              <div class="option-group">
                <label for="image-resize">Resize to max width (px):</label>
                <input type="number" id="image-resize" min="100" max="5000" placeholder="Leave empty for no resizing">
              </div>
            </div>
            <button class="tool-btn" id="compress-image-btn" onclick="compressImages()">Compress Images</button>
            <div class="preview-container" id="image-preview"></div>
            <div class="spinner" id="compress-image-spinner"></div>
            <div class="status-message" id="compress-image-status"></div>
          </div>
        </div>

        <!-- Background Color Changer -->
        <div class="tool-card fade-in" id="bg-changer-card">
          <h3>Background Color Changer</h3>
          <p>Change or remove background color from images.</p>
          <button class="tool-btn" onclick="toggleTool('bg-changer')">Use Tool</button>
          <div class="tool-content" id="bg-changer">
            <div class="file-input">
              <label>Select image to modify:</label>
              <div class="drag-drop-area" id="bg-changer-drop-area">
                <p>Drag & drop an image here</p>
                <p class="small">or click to browse</p>
              </div>
              <input type="file" id="bg-changer-file" accept="image/*">
              <div class="file-list" id="bg-changer-file-list"></div>
            </div>
            <div class="options">
              <div class="option-group">
                <label for="bg-action">Action:</label>
                <select id="bg-action">
                  <option value="change">Change Background Color</option>
                  <option value="remove">Remove Background</option>
                </select>
              </div>
              <div class="option-group" id="bg-color-group">
                <label for="bg-color">New Background Color:</label>
                <input type="color" id="bg-color" value="#ffffff">
              </div>
              <div class="option-group">
                <label for="bg-tolerance">Color Tolerance (for removal):</label>
                <input type="range" id="bg-tolerance" min="0" max="100" value="10">
                <span id="tolerance-value">10%</span>
              </div>
            </div>
            <button class="tool-btn" id="bg-change-btn" onclick="processBackground()">Process Image</button>
            <div class="preview-container">
              <div style="display: flex; justify-content: space-around; width: 100%;">
                <div>
                  <p>Original</p>
                  <img id="original-image-preview" style="max-height: 150px;">
                </div>
                <div>
                  <p>Result</p>
                  <img id="processed-image-preview" style="max-height: 150px;">
                </div>
              </div>
            </div>
            <div id="download-processed-container" style="margin-top: 1rem;"></div>
            <div class="spinner" id="bg-changer-spinner"></div>
            <div class="status-message" id="bg-changer-status"></div>
          </div>
        </div>

        <!-- QR Code Generator -->
        <div class="tool-card fade-in" id="qr-code-card">
          <h3>QR Code Generator</h3>
          <p>Create stylish QR codes from any link, text, or contact info.</p>
          <button class="tool-btn" onclick="toggleTool('qr-code')">Use Tool</button>
          <div class="tool-content" id="qr-code">
            <div class="options">
              <div class="option-group">
                <label for="qr-content">QR Code Content:</label>
                <input type="text" id="qr-content" placeholder="https://example.com">
              </div>
              <div class="option-group">
                <label for="qr-color">Color:</label>
                <input type="color" id="qr-color" value="#000000">
              </div>
              <div class="option-group">
                <label for="qr-bg-color">Background Color:</label>
                <input type="color" id="qr-bg-color" value="#ffffff">
              </div>
              <div class="option-group">
                <label for="qr-size">Size (px):</label>
                <input type="number" id="qr-size" min="100" max="1000" value="200">
              </div>
            </div>
            <button class="tool-btn" id="generate-qr-btn" onclick="generateQRCode()">Generate QR Code</button>
            <div class="qr-code-container" id="qr-code-container"></div>
            <button class="tool-btn secondary" id="download-qr-btn" style="display:none;" onclick="downloadQRCode()">Download QR Code</button>
            <div class="status-message" id="qr-code-status"></div>
          </div>
        </div>
      </div>
    </section>
  </section>

  <!-- About Section -->
  <section id="about" class="content-section content-page">
    <div class="content-container">
      <h1 class="fade-in">About Quick Merge</h1>
      
      <p class="fade-in">Quick Merge is a revolutionary client-side file processing tool that empowers you to merge, split, convert, and edit files directly in your browser—without ever compromising your privacy by uploading them to external servers.</p>
      
      <div class="feature-list fade-in">
        <h2>Why Choose Quick Merge?</h2>
        <div class="feature-item">
          <strong>Complete Privacy Assurance</strong> - Your files never leave your device, ensuring maximum security for sensitive documents
        </div>
        <div class="feature-item">
          <strong>No Account Required</strong> - Get started immediately without registration or login
        </div>
        <div class="feature-item">
          <strong>Professional-Grade Tools</strong> - Powerful features designed for both casual users and professionals
        </div>
        <div class="feature-item">
          <strong>Universal Compatibility</strong> - Works seamlessly across all modern browsers and devices
        </div>
      </div>
      
      <h2 class="fade-in">Our Technology</h2>
      <p class="fade-in">Quick Merge leverages cutting-edge web technologies to bring you:</p>
      <ul class="fade-in">
        <li>Advanced PDF manipulation using PDF-lib technology</li>
        <li>Efficient image processing with WebAssembly</li>
        <li>Client-side file handling with Web APIs</li>
        <li>Secure processing environment isolated from external networks</li>
      </ul>
      
      <h2 class="fade-in">Who Uses Quick Merge?</h2>
      <p class="fade-in">Our tools are trusted by professionals across industries:</p>
      <ul class="fade-in">
        <li>Legal professionals handling sensitive case documents</li>
        <li>Healthcare providers managing patient records</li>
        <li>Financial analysts working with confidential reports</li>
        <li>Students and educators organizing research materials</li>
        <li>Business professionals preparing presentations and contracts</li>
      </ul>
    </div>
  </section>

  <!-- Contact Section -->
  <section id="contact" class="content-section content-page">
    <div class="content-container">
      <h1 class="fade-in">Contact Quick Merge</h1>
      
      <div class="contact-box fade-in">
        <h2>Get in Touch</h2>
        <p>We're committed to providing exceptional support and value your feedback. Here's how you can reach us:</p>
        
        <div class="contact-method">
          <h3>Technical Support</h3>
          <p>Email: <a href="mailto:danielledawoodk@gmail.com">danielledawoodk@gmail.com</a></p>
          <p>For assistance with tool functionality, troubleshooting, or feature requests.</p>
        </div>
        
        <div class="contact-method">
          <h3>Privacy Questions</h3>
          <p>Email: <a href="mailto:danielledawoodk@gmail.com">danielledawoodk@gmail.com</a></p>
          <p>For any concerns regarding our privacy policy or data handling practices.</p>
        </div>
      </div>
      
      <h2 class="fade-in">Support Hours</h2>
      <p class="fade-in">Our team is available to assist you during the following hours:</p>
      <ul class="fade-in">
        <li>Monday-Friday: 9:00 AM - 5:00 PM (GMT)</li>
        <li>Emergency support available for critical issues</li>
        <li>Typical response time: 24-48 hours</li>
      </ul>
      
      <h2 class="fade-in">We Value Your Feedback</h2>
      <p class="fade-in">Help us improve Quick Merge by sharing your thoughts on:</p>
      <ul class="fade-in">
        <li>New features you'd like to see implemented</li>
        <li>Your experience with our current tools</li>
        <li>Any difficulties you've encountered</li>
        <li>Suggestions for improving our interface</li>
      </ul>
      
      <h2 class="fade-in">Business Partnerships</h2>
      <p class="fade-in">Interested in integrating Quick Merge technology into your platform?</p>
      <p class="fade-in">Contact our business development team at <a href="mailto:danielledawoodk@gmail.com">danielledawoodk@gmail.com</a> to discuss collaboration opportunities.</p>
    </div>
  </section>

  <!-- Privacy Policy Section -->
  <section id="privacy" class="content-section content-page">
    <div class="content-container">
      <h1 class="fade-in">Privacy Policy</h1>
      <p class="update-date fade-in">Last Updated: 21.05.2025</p>
      
      <div class="policy-section fade-in">
        <h2>Our Commitment to Privacy</h2>
        <p>At Quick Merge, we've built our platform on a fundamental principle: your data belongs to you. Unlike traditional online tools, we've designed our service to operate entirely within your browser, ensuring complete privacy and security.</p>
      </div>
      
      <div class="policy-section fade-in">
        <h2>How We Protect Your Data</h2>
        
        <h3>Local Processing Architecture</h3>
        <p>Our innovative approach means:</p>
        <ul>
          <li><strong>Zero Data Transmission:</strong> Files are processed directly in your browser with no server interaction</li>
          <li><strong>Automatic Cleanup:</strong> All temporary data is purged when you close your browser tab</li>
          <li><strong>No Tracking:</strong> We don't use cookies, analytics, or any tracking mechanisms</li>
        </ul>
        
        <h3>Security Features</h3>
        <p>We've implemented multiple safeguards:</p>
        <ul>
          <li>Modern encryption standards for all processing</li>
          <li>Sandboxed execution environment</li>
          <li>Regular security audits of our codebase</li>
        </ul>
      </div>
      
      <div class="policy-section fade-in">
        <h2>Your Responsibilities</h2>
        <p>While we provide the tools for secure processing, we recommend:</p>
        <ul>
          <li>Using updated browsers with security patches</li>
          <li>Avoiding public computers for sensitive documents</li>
          <li>Maintaining your device's antivirus protection</li>
        </ul>
      </div>
      
      <div class="policy-section fade-in">
        <h2>Policy Updates</h2>
        <p>We may occasionally update this policy to reflect:</p>
        <ul>
          <li>New features that maintain our privacy standards</li>
          <li>Changes in applicable laws and regulations</li>
          <li>Improvements to our security documentation</li>
        </ul>
        <p>We encourage you to review this policy periodically to stay informed about how we're protecting your information.</p>
      </div>
      
      <div class="policy-section fade-in">
        <h2>Contact Us</h2>
        <p>For any questions about this Privacy Policy or our practices, please contact our Privacy Officer at <a href="mailto:danielledawoodk@gmail.com">danielledawoodk@gmail.com</a>.</p>
      </div>
    </div>
  </section>

  <!-- Footer -->
  <footer>
    © 2025 Quick Merge – All rights reserved.
  </footer>

  <script>
    // Navigation function
    function showSection(sectionId) {
      // Hide all sections
      document.querySelectorAll('.content-section').forEach(section => {
        section.classList.remove('active-section');
      });
      
      // Show the selected section
      document.getElementById(sectionId).classList.add('active-section');
      
      // Scroll to top
      window.scrollTo(0, 0);
      
      // Trigger animations for the new section
      if (sectionId !== 'home') {
        setTimeout(() => {
          setupAnimations();
        }, 50);
      }
    }

    document.addEventListener('DOMContentLoaded', function() {
      // Initialize all tool sections
      setupDragAndDrop('merge-pdf', true);
      setupDragAndDrop('split-pdf', false);
      setupDragAndDrop('compress-pdf', false);
      setupDragAndDrop('compress-image', true);
      setupDragAndDrop('image-to-pdf', true);
      setupDragAndDrop('bg-changer', false);
     
      // Set up fade-in animations
      setupAnimations();
      
      // Setup quality slider
      const qualitySlider = document.getElementById('image-quality');
      const qualityValue = document.getElementById('quality-value');
      if (qualitySlider && qualityValue) {
        qualitySlider.addEventListener('input', function() {
          qualityValue.textContent = this.value + '%';
        });
      }
      
      // Setup tolerance slider
      const toleranceSlider = document.getElementById('bg-tolerance');
      const toleranceValue = document.getElementById('tolerance-value');
      if (toleranceSlider && toleranceValue) {
        toleranceSlider.addEventListener('input', function() {
          toleranceValue.textContent = this.value + '%';
        });
      }
      
      // Toggle background color input based on action
      const bgAction = document.getElementById('bg-action');
      const bgColorGroup = document.getElementById('bg-color-group');
      if (bgAction && bgColorGroup) {
        bgAction.addEventListener('change', function() {
          bgColorGroup.style.display = this.value === 'change' ? 'block' : 'none';
        });
      }
    });

    function setupDragAndDrop(toolId, allowMultiple) {
      const dropArea = document.getElementById(`${toolId}-drop-area`);
      const fileInput = document.getElementById(`${toolId}-${allowMultiple ? 'files' : 'file'}`);
      const fileList = document.getElementById(`${toolId}-file-list`);
      const actionBtn = document.getElementById(`${toolId}-btn`);

      if (!dropArea || !fileInput) {
        console.error(`Elements not found for tool: ${toolId}`);
        return;
      }

      // Prevent default drag behaviors
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropArea.addEventListener(eventName, preventDefaults, false);
        document.body.addEventListener(eventName, preventDefaults, false);
      });

      // Highlight drop area when item is dragged over it
      ['dragenter', 'dragover'].forEach(eventName => {
        dropArea.addEventListener(eventName, highlight, false);
      });

      ['dragleave', 'drop'].forEach(eventName => {
        dropArea.addEventListener(eventName, unhighlight, false);
      });

      // Handle dropped files
      dropArea.addEventListener('drop', function(e) {
        handleDrop(e, fileInput, fileList, actionBtn, allowMultiple);
      }, false);
      
      // Handle click to browse files
      dropArea.addEventListener('click', function() {
        fileInput.value = null; // Reset to allow selecting same file again
        fileInput.multiple = allowMultiple;
        fileInput.click();
      });

      // Handle file selection via input
      fileInput.addEventListener('change', function(e) {
        handleFiles(e.target.files, fileList, actionBtn);
        
        // For background changer, show preview
        if (toolId === 'bg-changer' && e.target.files.length > 0) {
          const file = e.target.files[0];
          const reader = new FileReader();
          reader.onload = function(event) {
            document.getElementById('original-image-preview').src = event.target.result;
          };
          reader.readAsDataURL(file);
        }
      });

      function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
      }

      function highlight() {
        dropArea.classList.add('active');
      }

      function unhighlight() {
        dropArea.classList.remove('active');
      }
    }

    function handleDrop(e, fileInput, fileList, actionBtn, allowMultiple) {
      const dt = e.dataTransfer;
      const files = dt.files;
      
      if (allowMultiple || files.length === 1) {
        // Update the file input with the dropped files
        fileInput.files = files;
        handleFiles(files, fileList, actionBtn);
        
        // For background changer, show preview
        if (fileInput.id === 'bg-changer-file' && files.length > 0) {
          const file = files[0];
          const reader = new FileReader();
          reader.onload = function(event) {
            document.getElementById('original-image-preview').src = event.target.result;
          };
          reader.readAsDataURL(file);
        }
      } else {
        showStatus('bg-changer', 'Please select only one file for this tool.', 'error');
      }
    }

    function handleFiles(files, fileListElement, actionBtn) {
      if (!files || files.length === 0) return;
      
      fileListElement.innerHTML = '';
      
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        const fileItem = document.createElement('div');
        fileItem.className = 'file-item';
        
        const fileNameSpan = document.createElement('span');
        fileNameSpan.className = 'file-item-name';
        fileNameSpan.textContent = file.name;
        
        const fileSizeSpan = document.createElement('span');
        fileSizeSpan.className = 'file-item-size';
        fileSizeSpan.textContent = formatFileSize(file.size);
        
        const removeSpan = document.createElement('span');
        removeSpan.className = 'file-item-remove';
        removeSpan.innerHTML = '&times;';
        removeSpan.addEventListener('click', function(e) {
          e.stopPropagation();
          fileItem.remove();
          // If no files left, disable the action button
          if (fileListElement.children.length === 0 && actionBtn) {
            actionBtn.disabled = true;
          }
        });
        
        fileItem.appendChild(fileNameSpan);
        fileItem.appendChild(fileSizeSpan);
        fileItem.appendChild(removeSpan);
        
        fileListElement.appendChild(fileItem);
      }
      
      // Enable the action button if files are selected
      if (actionBtn) {
        actionBtn.disabled = false;
      }
    }

    function formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    function toggleTool(toolId) {
      const toolCard = document.getElementById(`${toolId}-card`);
      const toolContent = document.getElementById(toolId);
      
      if (toolCard.classList.contains('active')) {
        toolCard.classList.remove('active');
        toolContent.style.display = 'none';
      } else {
        // Close all other tools first
        document.querySelectorAll('.tool-card.active').forEach(card => {
          card.classList.remove('active');
          card.querySelector('.tool-content').style.display = 'none';
        });
        
        toolCard.classList.add('active');
        toolContent.style.display = 'block';
      }
    }

    function setupAnimations() {
      const fadeElements = document.querySelectorAll('.fade-in');
      
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add('visible');
          }
        });
      }, { threshold: 0.1 });
      
      fadeElements.forEach(element => {
        observer.observe(element);
      });
    }

    function resetTool(toolId) {
      // Clear file inputs and lists
      const fileInput = document.getElementById(`${toolId}-${toolId.includes('merge') || toolId.includes('image-to-pdf') || toolId.includes('compress-image') ? 'files' : 'file'}`);
      const fileList = document.getElementById(`${toolId}-file-list`);
      
      if (fileInput) fileInput.value = '';
      if (fileList) fileList.innerHTML = '';
      
      // Disable action button
      const actionBtn = document.getElementById(`${toolId}-btn`);
      if (actionBtn) actionBtn.disabled = true;
      
      // Clear status messages
      const statusElement = document.getElementById(`${toolId}-status`);
      if (statusElement) {
        statusElement.textContent = '';
        statusElement.className = 'status-message';
      }
      
      // Hide spinner
      const spinner = document.getElementById(`${toolId}-spinner`);
      if (spinner) spinner.style.display = 'none';
      
      // For QR code tool, hide download button
      if (toolId === 'qr-code') {
        document.getElementById('download-qr-btn').style.display = 'none';
        document.getElementById('qr-code-container').innerHTML = '';
      }
      
      // For text converter, clear textarea
      if (toolId === 'text-converter') {
        document.getElementById('text-content').value = '';
      }
      
      // For background changer, clear previews and download button
      if (toolId === 'bg-changer') {
        document.getElementById('original-image-preview').src = '';
        document.getElementById('processed-image-preview').src = '';
        document.getElementById('download-processed-container').innerHTML = '';
      }
    }

    // PDF Processing Functions
    async function mergePDFs() {
      const fileInput = document.getElementById('merge-pdf-files');
      if (!fileInput.files || fileInput.files.length < 2) {
        showStatus('merge-pdf', 'Please select at least 2 PDF files to merge', 'error');
        return;
      }

      showStatus('merge-pdf', 'Merging PDFs...', 'processing');
      showSpinner('merge-pdf');
      
      try {
        const { PDFDocument } = PDFLib;
        const mergedPdf = await PDFDocument.create();
        
        // Process each file
        for (let i = 0; i < fileInput.files.length; i++) {
          const file = fileInput.files[i];
          const fileBuffer = await file.arrayBuffer();
          const pdfDoc = await PDFDocument.load(fileBuffer);
          
          // Copy pages
          const pages = await mergedPdf.copyPages(pdfDoc, pdfDoc.getPageIndices());
          pages.forEach(page => mergedPdf.addPage(page));
        }
        
        // Save merged PDF
        const mergedPdfBytes = await mergedPdf.save();
        const blob = new Blob([mergedPdfBytes], { type: 'application/pdf' });
        
        // Download the file
        saveAs(blob, 'merged-document.pdf');
        showStatus('merge-pdf', 'PDFs merged successfully!', 'success');
        
        // Reset tool after download
        setTimeout(() => resetTool('merge-pdf'), 2000);
      } catch (error) {
        console.error('Error merging PDFs:', error);
        showStatus('merge-pdf', 'Error merging PDFs: ' + error.message, 'error');
      } finally {
        hideSpinner('merge-pdf');
      }
    }

    async function splitPDF() {
      const fileInput = document.getElementById('split-pdf-file');
      const pagesInput = document.getElementById('split-pages');
      
      if (!fileInput.files || fileInput.files.length === 0) {
        showStatus('split-pdf', 'Please select a PDF file to split', 'error');
        return;
      }
      
      if (!pagesInput.value.trim()) {
        showStatus('split-pdf', 'Please specify pages to extract', 'error');
        return;
      }

      showStatus('split-pdf', 'Splitting PDF...', 'processing');
      showSpinner('split-pdf');
      
      try {
        const { PDFDocument } = PDFLib;
        const file = fileInput.files[0];
        const fileBuffer = await file.arrayBuffer();
        const pdfDoc = await PDFDocument.load(fileBuffer);
        
        // Parse page ranges
        const pageRanges = parsePageRanges(pagesInput.value, pdfDoc.getPageCount());
        if (pageRanges.length === 0) {
          showStatus('split-pdf', 'Invalid page range specified', 'error');
          return;
        }
        
        // Create new PDF with selected pages
        const newPdf = await PDFDocument.create();
        for (const pageNum of pageRanges) {
          const [copiedPage] = await newPdf.copyPages(pdfDoc, [pageNum - 1]);
          newPdf.addPage(copiedPage);
        }
        
        // Save split PDF
        const splitPdfBytes = await newPdf.save();
        const blob = new Blob([splitPdfBytes], { type: 'application/pdf' });
        
        // Download the file
        saveAs(blob, 'split-document.pdf');
        showStatus('split-pdf', 'PDF split successfully!', 'success');
        
        // Reset tool after download
        setTimeout(() => resetTool('split-pdf'), 2000);
      } catch (error) {
        console.error('Error splitting PDF:', error);
        showStatus('split-pdf', 'Error splitting PDF: ' + error.message, 'error');
      } finally {
        hideSpinner('split-pdf');
      }
    }

    function parsePageRanges(rangeStr, maxPages) {
      const ranges = rangeStr.split(',');
      const pages = new Set();
      
      for (const range of ranges) {
        if (range.includes('-')) {
          const [start, end] = range.split('-').map(Number);
          const validStart = Math.max(1, Math.min(start || 1, maxPages));
          const validEnd = Math.max(1, Math.min(end || maxPages, maxPages));
          
          for (let i = validStart; i <= validEnd; i++) {
            pages.add(i);
          }
        } else if (range.trim()) {
          const page = Number(range);
          if (page >= 1 && page <= maxPages) {
            pages.add(page);
          }
        }
      }
      
      return Array.from(pages).sort((a, b) => a - b);
    }

    async function compressPDF() {
      const fileInput = document.getElementById('compress-pdf-file');
      const compressionLevel = document.getElementById('compression-level').value;
      
      if (!fileInput.files || fileInput.files.length === 0) {
        showStatus('compress-pdf', 'Please select a PDF file to compress', 'error');
        return;
      }

      showStatus('compress-pdf', 'Compressing PDF...', 'processing');
      showSpinner('compress-pdf');
      
      try {
        const { PDFDocument } = PDFLib;
        const file = fileInput.files[0];
        const fileBuffer = await file.arrayBuffer();
        const pdfDoc = await PDFDocument.load(fileBuffer);
        
        // Set compression options based on level
        const options = {
          useObjectStreams: true,
          // Default options for medium compression
          throwOnInvalidImage: true,
          ignoreInvalidAnnotations: false,
          forceJPEGCompression: false,
          quality: 0.9
        };
        
        // Adjust options based on compression level
        if (compressionLevel === 'low') {
          options.quality = 1.0;
          options.useObjectStreams = false;
        } else if (compressionLevel === 'high') {
          options.quality = 0.7;
          options.throwOnInvalidImage = false;
          options.ignoreInvalidAnnotations = true;
        } else if (compressionLevel === 'extreme') {
          options.quality = 0.5;
          options.throwOnInvalidImage = false;
          options.ignoreInvalidAnnotations = true;
          options.forceJPEGCompression = true;
        }
        
        // Save compressed PDF
        const compressedPdfBytes = await pdfDoc.save(options);
        const blob = new Blob([compressedPdfBytes], { type: 'application/pdf' });
        
        // Calculate compression ratio
        const originalSize = file.size;
        const compressedSize = blob.size;
        const ratio = ((originalSize - compressedSize) / originalSize * 100).toFixed(2);
        
        // Download the file
        saveAs(blob, 'compressed-document.pdf');
        showStatus('compress-pdf', `PDF compressed successfully! Size reduced by ${ratio}%`, 'success');
        
        // Reset tool after download
        setTimeout(() => resetTool('compress-pdf'), 2000);
      } catch (error) {
        console.error('Error compressing PDF:', error);
        showStatus('compress-pdf', 'Error compressing PDF: ' + error.message, 'error');
      } finally {
        hideSpinner('compress-pdf');
      }
    }

    async function convertImagesToPDF() {
      const fileInput = document.getElementById('image-to-pdf-files');
      const layout = document.getElementById('pdf-layout').value;
      const margin = parseInt(document.getElementById('pdf-margin').value);
      
      if (!fileInput.files || fileInput.files.length === 0) {
        showStatus('image-to-pdf', 'Please select at least one image to convert', 'error');
        return;
      }

      showStatus('image-to-pdf', 'Converting images to PDF...', 'processing');
      showSpinner('image-to-pdf');
      
      try {
        const { PDFDocument, rgb } = PDFLib;
        const pdfDoc = await PDFDocument.create();
        
        // Process each image
        for (let i = 0; i < fileInput.files.length; i++) {
          const file = fileInput.files[i];
          if (!file.type.match('image.*')) continue;
          
          // Convert image to data URL
          const imageBytes = await file.arrayBuffer();
          let image;
          
          try {
            if (file.type === 'image/jpeg' || file.type === 'image/jpg') {
              image = await pdfDoc.embedJpg(imageBytes);
            } else if (file.type === 'image/png') {
              image = await pdfDoc.embedPng(imageBytes);
            } else {
              // For other image types, convert to JPEG first
              const convertedImage = await convertImageToJpeg(file);
              image = await pdfDoc.embedJpg(await convertedImage.arrayBuffer());
            }
            
            // Determine page size based on layout and image dimensions
            let pageWidth, pageHeight;
            const marginPoints = margin * 2.83465; // Convert mm to points (1mm = 2.83465pt)
            
            if (layout === 'auto') {
              // Match image orientation
              pageWidth = image.width + (marginPoints * 2);
              pageHeight = image.height + (marginPoints * 2);
            } else if (layout === 'landscape') {
              // Landscape (width > height)
              const ratio = image.width / image.height;
              if (ratio > 1) {
                pageWidth = image.width + (marginPoints * 2);
                pageHeight = image.height + (marginPoints * 2);
              } else {
                pageWidth = image.height + (marginPoints * 2);
                pageHeight = image.width + (marginPoints * 2);
              }
            } else {
              // Portrait (height > width)
              const ratio = image.width / image.height;
              if (ratio < 1) {
                pageWidth = image.width + (marginPoints * 2);
                pageHeight = image.height + (marginPoints * 2);
              } else {
                pageWidth = image.height + (marginPoints * 2);
                pageHeight = image.width + (marginPoints * 2);
              }
            }
            
            // Add a new page with the calculated dimensions
            const page = pdfDoc.addPage([pageWidth, pageHeight]);
            
            // Draw the image centered on the page with margins
            const scale = Math.min(
              (pageWidth - marginPoints * 2) / image.width,
              (pageHeight - marginPoints * 2) / image.height
            );
            
            const scaledWidth = image.width * scale;
            const scaledHeight = image.height * scale;
            
            page.drawImage(image, {
              x: (pageWidth - scaledWidth) / 2,
              y: (pageHeight - scaledHeight) / 2,
              width: scaledWidth,
              height: scaledHeight,
            });
          } catch (error) {
            console.error(`Error processing image ${file.name}:`, error);
            continue;
          }
        }
        
        if (pdfDoc.getPageCount() === 0) {
          showStatus('image-to-pdf', 'No valid images were processed', 'error');
          return;
        }
        
        // Save the PDF
        const pdfBytes = await pdfDoc.save();
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        
        // Download the file
        saveAs(blob, 'converted-images.pdf');
        showStatus('image-to-pdf', 'Images converted to PDF successfully!', 'success');
        
        // Reset tool after download
        setTimeout(() => resetTool('image-to-pdf'), 2000);
      } catch (error) {
        console.error('Error converting images to PDF:', error);
        showStatus('image-to-pdf', 'Error: ' + error.message, 'error');
      } finally {
        hideSpinner('image-to-pdf');
      }
    }

    async function convertImageToJpeg(file) {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = function(event) {
          const img = new Image();
          img.onload = function() {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            
            canvas.toBlob((blob) => {
              resolve(new File([blob], file.name.replace(/\.[^/.]+$/, '.jpg'), { type: 'image/jpeg' }));
            }, 'image/jpeg', 0.9);
          };
          img.src = event.target.result;
        };
        reader.readAsDataURL(file);
      });
    }

    async function convertTextToDocument() {
      const textContent = document.getElementById('text-content').value;
      const filename = document.getElementById('text-filename').value || 'document';
      const format = document.getElementById('text-format').value;
      
      if (!textContent.trim()) {
        showStatus('text-converter', 'Please enter some text to convert', 'error');
        return;
      }

      showStatus('text-converter', 'Converting text...', 'processing');
      showSpinner('text-converter');
      
      try {
        if (format === 'docx') {
          await generateWordDocument(textContent, filename);
        } else {
          await generatePDFFromText(textContent, filename);
        }
        
        showStatus('text-converter', 'Document created successfully!', 'success');
        setTimeout(() => resetTool('text-converter'), 2000);
      } catch (error) {
        console.error('Error converting text:', error);
        showStatus('text-converter', 'Error: ' + error.message, 'error');
      } finally {
        hideSpinner('text-converter');
      }
    }

    async function generateWordDocument(text, filename) {
      const { Document, Paragraph, TextRun, Packer } = docx;
      
      const doc = new Document({
        sections: [{
          properties: {},
          children: [
            new Paragraph({
              children: [
                new TextRun({
                  text: text,
                  size: 24, // 12pt
                }),
              ],
            }),
          ],
        }],
      });
      
      const mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
      const blob = await Packer.toBlob(doc);
      saveAs(blob, `${filename}.docx`);
    }

    async function generatePDFFromText(text, filename) {
      const { PDFDocument, rgb } = PDFLib;
      
      const pdfDoc = await PDFDocument.create();
      const page = pdfDoc.addPage([595.28, 841.89]); // A4 size in points
      
      const { width, height } = page.getSize();
      const fontSize = 12;
      const margin = 50;
      
      page.drawText(text, {
        x: margin,
        y: height - margin - fontSize,
        size: fontSize,
        color: rgb(0, 0, 0),
        lineHeight: fontSize * 1.2,
        maxWidth: width - margin * 2,
      });
      
      const pdfBytes = await pdfDoc.save();
      const blob = new Blob([pdfBytes], { type: 'application/pdf' });
      saveAs(blob, `${filename}.pdf`);
    }

    async function compressImages() {
      const fileInput = document.getElementById('compress-image-files');
      const quality = document.getElementById('image-quality').value / 100;
      const maxWidth = document.getElementById('image-resize').value;
      
      if (!fileInput.files || fileInput.files.length === 0) {
        showStatus('compress-image', 'Please select at least one image to compress', 'error');
        return;
      }

      showStatus('compress-image', 'Compressing images...', 'processing');
      showSpinner('compress-image');
      
      try {
        // Load JSZip dynamically if not available
        if (typeof JSZip === 'undefined') {
          await loadScript('https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js');
        }

        const zip = new JSZip();
        let imgCount = 0;

        // Process each image with better compression
        for (let i = 0; i < fileInput.files.length; i++) {
          const file = fileInput.files[i];
          if (!file.type.match('image.*')) continue;

          // Improved compression using canvas with optional resizing
          const compressedBlob = await compressImageFile(file, quality, maxWidth);
          
          if (compressedBlob) {
            zip.file(`compressed_${file.name}`, compressedBlob);
            imgCount++;
          }
        }

        if (imgCount === 0) {
          showStatus('compress-image', 'No valid images found', 'error');
          return;
        }

        // Generate ZIP with better compression
        const zipContent = await zip.generateAsync({
          type: 'blob',
          compression: 'DEFLATE',
          compressionOptions: { level: 6 }
        });

        saveAs(zipContent, 'compressed_images.zip');
        showStatus('compress-image', `${imgCount} images compressed successfully!`, 'success');
        
        setTimeout(() => resetTool('compress-image'), 2000);
      } catch (error) {
        console.error('Error compressing images:', error);
        showStatus('compress-image', 'Error: ' + error.message, 'error');
      } finally {
        hideSpinner('compress-image');
      }
    }

    // Helper function for better image compression with optional resizing
    async function compressImageFile(file, quality, maxWidth) {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = function(event) {
          const img = new Image();
          img.onload = function() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Calculate dimensions
            let width = img.width;
            let height = img.height;
            
            // Resize if maxWidth is specified and image is larger
            if (maxWidth && width > maxWidth) {
              const ratio = maxWidth / width;
              width = maxWidth;
              height = height * ratio;
            }
            
            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);
            
            // Convert to Blob with quality control
            canvas.toBlob((blob) => {
              resolve(blob);
            }, file.type, quality);
          };
          img.src = event.target.result;
        };
        reader.readAsDataURL(file);
      });
    }

    async function processBackground() {
      const fileInput = document.getElementById('bg-changer-file');
      const action = document.getElementById('bg-action').value;
      const bgColor = document.getElementById('bg-color').value;
      const tolerance = parseInt(document.getElementById('bg-tolerance').value) / 100;
      
      if (!fileInput.files || fileInput.files.length === 0) {
        showStatus('bg-changer', 'Please select an image to process', 'error');
        return;
      }

      showStatus('bg-changer', 'Processing image...', 'processing');
      showSpinner('bg-changer');
      
      try {
        const file = fileInput.files[0];
        const resultBlob = await processImageBackground(file, action, bgColor, tolerance);
        
        if (!resultBlob) {
          showStatus('bg-changer', 'Error processing image', 'error');
          return;
        }
        
        // Show result preview
        const resultUrl = URL.createObjectURL(resultBlob);
        document.getElementById('processed-image-preview').src = resultUrl;
        
        // Create download button
        const downloadContainer = document.getElementById('download-processed-container');
        downloadContainer.innerHTML = '';
        
        const downloadBtn = document.createElement('a');
        downloadBtn.className = 'tool-btn';
        downloadBtn.textContent = 'Download Processed Image';
        downloadBtn.href = resultUrl;
        downloadBtn.download = `processed_${file.name}`;
        downloadContainer.appendChild(downloadBtn);
        
        showStatus('bg-changer', 'Image processed successfully!', 'success');
      } catch (error) {
        console.error('Error processing image background:', error);
        showStatus('bg-changer', 'Error: ' + error.message, 'error');
      } finally {
        hideSpinner('bg-changer');
      }
    }

    async function processImageBackground(file, action, bgColor, tolerance) {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = function(event) {
          const img = new Image();
          img.onload = function() {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            
            // Draw the original image
            ctx.drawImage(img, 0, 0);
            
            if (action === 'remove') {
              // Get image data
              const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
              const data = imageData.data;
              
              // Get the color of the top-left pixel as the background color to remove
              const r = data[0];
              const g = data[1];
              const b = data[2];
              
              // Process all pixels
              for (let i = 0; i < data.length; i += 4) {
                const pixelR = data[i];
                const pixelG = data[i + 1];
                const pixelB = data[i + 2];
                
                // Calculate color distance
                const distance = Math.sqrt(
                  Math.pow(pixelR - r, 2) +
                  Math.pow(pixelG - g, 2) +
                  Math.pow(pixelB - b, 2)
                ) / 441.6729559300637; // Normalize to 0-1 (441.67 is max possible distance)
                
                // If pixel is within tolerance of the background color, make it transparent
                if (distance <= tolerance) {
                  data[i + 3] = 0; // Set alpha to 0 (transparent)
                }
              }
              
              // Put the modified image data back
              ctx.putImageData(imageData, 0, 0);
            } else {
              // Change background color
              // First create a new canvas with the background color
              ctx.fillStyle = bgColor;
              ctx.fillRect(0, 0, canvas.width, canvas.height);
              
              // Then draw the original image on top
              ctx.drawImage(img, 0, 0);
            }
            
            // Convert to Blob
            canvas.toBlob((blob) => {
              resolve(blob);
            }, file.type);
          };
          img.src = event.target.result;
        };
        reader.readAsDataURL(file);
      });
    }

    function generateQRCode() {
      const container = document.getElementById('qr-code-container');
      const content = document.getElementById('qr-content').value;
      const color = document.getElementById('qr-color').value;
      const bgColor = document.getElementById('qr-bg-color').value;
      const size = document.getElementById('qr-size').value;
      
      if (!content) {
        showStatus('qr-code', 'Please enter content for the QR code', 'error');
        return;
      }
      
      container.innerHTML = '';
      new QRCode(container, {
        text: content,
        width: size,
        height: size,
        colorDark: color,
        colorLight: bgColor,
        correctLevel: QRCode.CorrectLevel.H
      });
      
      document.getElementById('download-qr-btn').style.display = 'block';
      showStatus('qr-code', 'QR code generated successfully!', 'success');
    }

    function downloadQRCode() {
      const container = document.getElementById('qr-code-container');
      const canvas = container.querySelector('canvas');
      const link = document.createElement('a');
      link.download = 'qrcode.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
      
      // Reset tool after download
      setTimeout(() => {
        document.getElementById('qr-code-container').innerHTML = '';
        document.getElementById('download-qr-btn').style.display = 'none';
        document.getElementById('qr-content').value = '';
        showStatus('qr-code', '', '');
      }, 2000);
    }

    // Helper functions
    function showStatus(toolId, message, type) {
      const statusElement = document.getElementById(`${toolId}-status`);
      if (!statusElement) return;
      
      statusElement.textContent = message;
      statusElement.className = 'status-message';
      
      if (type === 'processing') {
        statusElement.classList.remove('success', 'error');
      } else if (type) {
        statusElement.classList.add(type);
      }
    }

    function showSpinner(toolId) {
      const spinner = document.getElementById(`${toolId}-spinner`);
      if (spinner) spinner.style.display = 'block';
    }

    function hideSpinner(toolId) {
      const spinner = document.getElementById(`${toolId}-spinner`);
      if (spinner) spinner.style.display = 'none';
    }

    // Dynamically load JS if missing
    function loadScript(src) {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }
  </script>
</body>
</html>