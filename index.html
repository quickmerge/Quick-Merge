<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quick Merge – Merge, Compress & Convert Files Instantly</title>
  <meta name="description" content="Quick Merge offers fast, secure file processing tools including PDF merging, splitting, compression, image conversion, and QR code generation - all processed locally in your browser.">
  <meta name="keywords" content="PDF merge, PDF split, compress PDF, image to PDF, QR code generator, file converter, online tools, privacy-focused tools">
  <meta name="author" content="Quick Merge">
  <meta name="robots" content="index, follow">
  <meta property="og:title" content="Quick Merge - File Processing Tools">
  <meta property="og:description" content="Merge, compress and convert files instantly with our privacy-focused browser tools">
  <meta property="og:type" content="website">
  
  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
  <!-- Font Awesome for hamburger icon -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  
  <!-- Required Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/docx/7.8.2/docx.min.js"></script>
  
  <!-- Enhanced Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/@imgly/background-removal@1.4.5/dist/index.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.2/dist/browser-image-compression.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qr-code-styling@1.6.0/lib/qr-code-styling.js"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(to right, #0f0f10, #111215);
      color: #f0f0f0;
      line-height: 1.6;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    a {
      text-decoration: none;
      color: inherit;
    }

    /* Header */
    header {
      background: rgba(15, 15, 16, 0.95);
      position: sticky;
      top: 0;
      z-index: 1000;
      backdrop-filter: blur(10px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }

    .nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      max-width: 1200px;
      margin: auto;
      padding: 1rem 2rem;
    }

    .nav h1 {
      font-size: 1.5rem;
      font-weight: 700;
      background: linear-gradient(90deg, #00f6ff, #6c5dd3);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .nav .nav-links {
      display: flex;
      gap: 1.5rem;
    }

    .nav .nav-links a {
      font-size: 1rem;
      color: #ccc;
      transition: color 0.2s;
    }

    .nav .nav-links a:hover {
      color: #fff;
    }

    /* Mobile menu styles */
    .mobile-menu-btn {
      display: none;
      background: none;
      border: none;
      color: #ccc;
      font-size: 1.5rem;
      cursor: pointer;
    }

    .mobile-menu {
      display: none;
      position: fixed;
      top: 70px;
      left: 0;
      right: 0;
      background: rgba(15, 15, 16, 0.98);
      padding: 1rem;
      z-index: 999;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    .mobile-menu.active {
      display: block;
    }

    .mobile-menu a {
      display: block;
      padding: 0.8rem 1rem;
      color: #ccc;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    .mobile-menu a:hover {
      color: #fff;
      background: rgba(108, 93, 211, 0.1);
    }

    .container {
      max-width: 1200px;
      margin: auto;
      padding: 2rem;
      flex: 1;
    }

    .hero {
      text-align: center;
      padding: 5rem 2rem 3rem;
    }

    .hero h2 {
      font-size: 2.8rem;
      background: linear-gradient(90deg, #00f6ff, #6c5dd3);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .hero p {
      color: #aaa;
      margin-top: 1rem;
      font-size: 1.2rem;
    }

    .cta {
      margin-top: 2rem;
    }

    .cta button {
      background: #6c5dd3;
      color: white;
      padding: 0.8rem 1.6rem;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      cursor: pointer;
      transition: 0.3s ease;
    }

    .cta button:hover {
      background: #5842c3;
    }

    /* Tool Cards Grid */
    .tools {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 2rem;
      margin-top: 4rem;
    }

    .tool-card {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(14px);
      border-radius: 14px;
      padding: 2rem;
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 0 20px rgba(108, 93, 211, 0.08);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .tool-card:hover {
      transform: translateY(-6px);
      box-shadow: 0 0 28px rgba(108, 93, 211, 0.25);
    }

    .tool-card h3 {
      font-size: 1.3rem;
      color: #fff;
      margin-bottom: 0.5rem;
    }

    .tool-card p {
      color: #bbb;
      font-size: 0.95rem;
    }

    /* Tool Content */
    .tool-content {
      display: none;
      margin-top: 1.5rem;
    }

    .tool-card.active {
      padding-bottom: 2.5rem;
    }

    .tool-card.active .tool-content {
      display: block;
    }

    .file-input {
      width: 100%;
      margin-bottom: 1rem;
    }

    .file-input label {
      display: block;
      margin-bottom: 0.5rem;
      color: #ddd;
      font-size: 0.9rem;
    }

    .file-input input[type="file"] {
      width: 100%;
      padding: 0.5rem;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      color: #fff;
      display: none;
    }

    .drag-drop-area {
      width: 100%;
      padding: 2rem;
      border: 2px dashed rgba(255,255,255,0.3);
      border-radius: 8px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
      margin-bottom: 1rem;
    }

    .drag-drop-area:hover {
      border-color: #6c5dd3;
      background: rgba(108, 93, 211, 0.1);
    }

    .drag-drop-area.active {
      border-color: #6c5dd3;
      background: rgba(108, 93, 211, 0.2);
    }

    .drag-drop-area p {
      margin-bottom: 0.5rem;
    }

    .drag-drop-area .small {
      font-size: 0.8rem;
      color: #aaa;
    }

    .file-list {
      margin-top: 1rem;
      max-height: 150px;
      overflow-y: auto;
    }

    .file-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem;
      background: rgba(255,255,255,0.05);
      border-radius: 4px;
      margin-bottom: 0.3rem;
    }

    .file-item-name {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 70%;
    }

    .file-item-size {
      font-size: 0.8rem;
      color: #aaa;
    }

    .file-item-remove {
      color: #ff6b6b;
      cursor: pointer;
      margin-left: 0.5rem;
    }

    .tool-btn {
      background: #6c5dd3;
      color: white;
      padding: 0.6rem 1.2rem;
      border: none;
      border-radius: 6px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: 0.3s ease;
      margin-top: 0.5rem;
      width: 100%;
    }

    .tool-btn:hover {
      background: #5842c3;
    }

    .tool-btn.secondary {
      background: transparent;
      border: 1px solid #6c5dd3;
      margin-top: 0.5rem;
    }

    .tool-btn:disabled {
      background: #555;
      cursor: not-allowed;
      opacity: 0.7;
    }

    .options {
      margin: 1rem 0;
    }

    .option-group {
      margin-bottom: 1rem;
    }

    .option-group label {
      display: block;
      margin-bottom: 0.3rem;
      color: #ddd;
      font-size: 0.9rem;
    }

    .option-group input[type="text"],
    .option-group input[type="number"],
    .option-group select,
    .option-group textarea {
      width: 100%;
      padding: 0.5rem;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      color: #fff;
    }

    .option-group input[type="range"] {
      width: 100%;
    }

    .option-group input[type="color"] {
      width: 100%;
      height: 40px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }

    .preview-container {
      margin-top: 1rem;
      text-align: center;
    }

    .preview-container img {
      max-width: 100%;
      max-height: 200px;
      border-radius: 6px;
    }

    .qr-code-container {
      display: flex;
      justify-content: center;
      margin: 1rem 0;
    }

    .qr-preview {
      margin: 1rem 0;
      text-align: center;
    }

    .qr-preview canvas {
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    /* Signature Canvas */
    .signature-container {
      margin: 1rem 0;
      text-align: center;
    }

    .signature-canvas {
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      background: rgba(255,255,255,0.05);
      cursor: crosshair;
      margin: 0 auto;
      display: block;
    }

    .signature-options {
      margin-top: 1rem;
    }

    .signature-btn {
      background: #6c5dd3;
      color: white;
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 6px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: 0.3s ease;
      margin-right: 0.5rem;
    }

    .signature-btn:hover {
      background: #5842c3;
    }

    .signature-btn.clear {
      background: #ff6b6b;
    }

    .signature-btn.clear:hover {
      background: #e74c3c;
    }

    /* Status messages */
    .status-message {
      margin-top: 1rem;
      padding: 0.5rem;
      border-radius: 4px;
      font-size: 0.9rem;
      text-align: center;
    }

    .status-message.success {
      background: rgba(46, 204, 113, 0.2);
      color: #2ecc71;
    }

    .status-message.error {
      background: rgba(231, 76, 60, 0.2);
      color: #e74c3c;
    }

    .status-message.processing {
      background: rgba(52, 152, 219, 0.2);
      color: #3498db;
    }

    /* About, Contact, Privacy pages styles */
    .content-page {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .content-container {
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem;
      flex: 1;
    }

    .content-page h1 {
      font-size: 2.5rem;
      margin-bottom: 1.5rem;
      background: linear-gradient(90deg, #00f6ff, #6c5dd3);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-align: center;
      padding-bottom: 0.5rem;
    }

    .content-page h2 {
      font-size: 1.8rem;
      margin: 2rem 0 1rem;
      color: #fff;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      padding-bottom: 0.5rem;
    }

    .content-page h3 {
      font-size: 1.3rem;
      margin: 1.5rem 0 1rem;
      color: #ddd;
    }

    .content-page p {
      margin-bottom: 1.2rem;
      color: #bbb;
      line-height: 1.7;
      font-size: 1.05rem;
    }

    .content-page ul, .content-page ol {
      margin-bottom: 1.5rem;
      padding-left: 2rem;
    }

    .content-page li {
      margin-bottom: 0.7rem;
      color: #bbb;
      line-height: 1.6;
    }

    .feature-list, .contact-box, .policy-section {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(14px);
      border-radius: 14px;
      padding: 1.8rem;
      margin: 2rem 0;
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 0 20px rgba(108, 93, 211, 0.08);
    }

    .feature-item {
      margin-bottom: 1rem;
      padding-left: 1rem;
      border-left: 3px solid #6c5dd3;
    }

    .contact-method {
      margin-bottom: 1.5rem;
      padding: 1rem;
      background: rgba(108, 93, 211, 0.1);
      border-radius: 8px;
    }

    .contact-method h3 {
      color: #6c5dd3;
      margin-bottom: 0.5rem;
    }

    .content-page a {
      color: #6c5dd3;
      transition: color 0.2s;
      text-decoration: underline;
    }

    .content-page a:hover {
      color: #00f6ff;
    }

    .update-date {
      font-style: italic;
      color: #aaa;
      margin-bottom: 1.5rem;
      display: block;
      text-align: center;
      font-size: 0.95rem;
    }

    .privacy-notice {
      text-align: center;
      margin: 3rem 0;
      padding: 2rem;
      background: rgba(108, 93, 211, 0.1);
      border-radius: 14px;
      border: 1px solid rgba(108, 93, 211, 0.2);
    }

    .privacy-notice h2 {
      font-size: 2rem;
      background: linear-gradient(90deg, #00f6ff, #6c5dd3);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      border: none;
      margin-bottom: 1rem;
    }

    .privacy-notice p {
      font-size: 1.1rem;
      max-width: 700px;
      margin: 0 auto;
    }

    /* Footer */
    footer {
      margin-top: auto;
      padding: 2rem;
      text-align: center;
      font-size: 0.9rem;
      color: #666;
      border-top: 1px solid #222;
    }

    /* Fade In Animation */
    .fade-in {
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.8s ease;
    }

    .fade-in.visible {
      opacity: 1;
      transform: translateY(0);
    }

    /* Loading spinner */
    .spinner {
      display: none;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 1s ease-in-out infinite;
      margin: 0 auto;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Hide content sections by default */
    .content-section {
      display: none;
    }

    .active-section {
      display: block;
    }

    /* Accessibility improvements */
    button:focus, input:focus, select:focus, textarea:focus {
      outline: 2px solid #6c5dd3;
      outline-offset: 2px;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .hero h2 {
        font-size: 2rem;
        line-height: 1.2;
      }

      .hero {
        padding: 3rem 1rem 2rem;
      }

      .content-page h1 {
        font-size: 1.8rem;
      }

      .content-page h2 {
        font-size: 1.5rem;
      }

      .nav .nav-links {
        display: none;
      }

      .mobile-menu-btn {
        display: block;
      }

      .content-container, .container {
        padding: 1rem;
      }
      
      .tools {
        grid-template-columns: 1fr;
        gap: 1.5rem;
      }

      .tool-card {
        padding: 1.5rem;
      }

      .drag-drop-area {
        padding: 1.5rem;
      }

      .option-group {
        margin-bottom: 0.8rem;
      }

      .option-group label {
        font-size: 0.85rem;
      }

      .option-group input[type="text"],
      .option-group input[type="number"],
      .option-group select,
      .option-group textarea {
        padding: 0.4rem;
        font-size: 0.9rem;
      }

      .tool-btn {
        padding: 0.5rem 1rem;
        font-size: 0.85rem;
      }
    }

    @media (max-width: 480px) {
      .hero h2 {
        font-size: 1.7rem;
      }

      .hero p {
        font-size: 1rem;
      }

      .nav {
        padding: 0.8rem 1rem;
      }

      .nav h1 {
        font-size: 1.3rem;
      }

      .mobile-menu-btn {
        font-size: 1.3rem;
      }

      .mobile-menu {
        top: 60px;
      }

      .tool-card h3 {
        font-size: 1.2rem;
      }

      .tool-card p {
        font-size: 0.9rem;
      }

      .drag-drop-area {
        padding: 1rem;
      }

      .drag-drop-area p {
        font-size: 0.9rem;
      }

      .drag-drop-area .small {
        font-size: 0.75rem;
      }
    }

    @media (min-width: 769px) {
      .mobile-menu {
        display: none !important;
      }
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header>
    <div class="nav">
      <h1>Quick Merge</h1>
      <div class="nav-links">
        <a href="#" onclick="showSection('home')">Home</a>
        <a href="#" onclick="showSection('about')">About</a>
        <a href="#" onclick="showSection('contact')">Contact</a>
        <a href="#" onclick="showSection('privacy')">Privacy</a>
      </div>
      <button class="mobile-menu-btn" onclick="toggleMobileMenu()">
        <i class="fas fa-bars"></i>
      </button>
    </div>
    <div class="mobile-menu" id="mobileMenu">
      <a href="#" onclick="showSection('home'); toggleMobileMenu()">Home</a>
      <a href="#" onclick="showSection('about'); toggleMobileMenu()">About</a>
      <a href="#" onclick="showSection('contact'); toggleMobileMenu()">Contact</a>
      <a href="#" onclick="showSection('privacy'); toggleMobileMenu()">Privacy</a>
    </div>
  </header>

  <!-- Home Section -->
  <section id="home" class="content-section active-section">
    <!-- Hero -->
    <section class="hero">
      <div class="container">
        <h2>Merge, Compress & Convert Files Instantly</h2>
        <p>All tools run locally in your browser — fast, private, and secure.</p>
        <div class="cta">
          <button onclick="document.getElementById('tools').scrollIntoView({ behavior: 'smooth' })">Explore Tools</button>
        </div>
      </div>
    </section>

    <!-- Tools -->
    <section id="tools" class="container">
      <div class="tools">
        <!-- Merge PDF -->
        <div class="tool-card fade-in" id="merge-pdf-card">
          <h3>Merge PDF</h3>
          <p>Combine multiple PDF files into one seamless document.</p>
          <button class="tool-btn" onclick="toggleTool('merge-pdf')">Use Tool</button>
          <div class="tool-content" id="merge-pdf">
            <div class="file-input">
              <label for="merge-pdf-files">Select PDF files to merge:</label>
              <div class="drag-drop-area" id="merge-pdf-drop-area" tabindex="0" role="button" aria-label="Drag and drop area for PDF files">
                <p>Drag & drop PDF files here</p>
                <p class="small">or click to browse</p>
              </div>
              <input type="file" id="merge-pdf-files" accept=".pdf" multiple>
              <div class="file-list" id="merge-pdf-file-list"></div>
            </div>
            <button class="tool-btn" id="merge-pdf-btn" onclick="mergePDFs()" disabled>Merge PDFs</button>
            <div class="spinner" id="merge-pdf-spinner"></div>
            <div class="status-message" id="merge-pdf-status"></div>
          </div>
        </div>

        <!-- Split PDF -->
        <div class="tool-card fade-in" id="split-pdf-card">
          <h3>Split PDF</h3>
          <p>Extract selected pages or split PDF into multiple parts.</p>
          <button class="tool-btn" onclick="toggleTool('split-pdf')">Use Tool</button>
          <div class="tool-content" id="split-pdf">
            <div class="file-input">
              <label for="split-pdf-file">Select PDF file to split:</label>
              <div class="drag-drop-area" id="split-pdf-drop-area" tabindex="0" role="button" aria-label="Drag and drop area for PDF files">
                <p>Drag & drop a PDF file here</p>
                <p class="small">or click to browse</p>
              </div>
              <input type="file" id="split-pdf-file" accept=".pdf">
              <div class="file-list" id="split-pdf-file-list"></div>
            </div>
            <div class="options">
              <div class="option-group">
                <label for="split-pages">Pages to extract (e.g., 1-3,5,7-9):</label>
                <input type="text" id="split-pages" placeholder="1-3,5,7-9">
              </div>
            </div>
            <button class="tool-btn" id="split-pdf-btn" onclick="splitPDF()" disabled>Split PDF</button>
            <div class="spinner" id="split-pdf-spinner"></div>
            <div class="status-message" id="split-pdf-status"></div>
          </div>
        </div>

        <!-- Compress PDF -->
        <div class="tool-card fade-in" id="compress-pdf-card">
          <h3>Compress PDF</h3>
          <p>Reduce PDF file size without losing quality or formatting.</p>
          <button class="tool-btn" onclick="toggleTool('compress-pdf')">Use Tool</button>
          <div class="tool-content" id="compress-pdf">
            <div class="file-input">
              <label for="compress-pdf-file">Select PDF file to compress:</label>
              <div class="drag-drop-area" id="compress-pdf-drop-area" tabindex="0" role="button" aria-label="Drag and drop area for PDF files">
                <p>Drag & drop a PDF file here</p>
                <p class="small">or click to browse</p>
              </div>
              <input type="file" id="compress-pdf-file" accept=".pdf">
              <div class="file-list" id="compress-pdf-file-list"></div>
            </div>
            <div class="options">
              <div class="option-group">
                <label for="compression-level">Compression level:</label>
                <select id="compression-level">
                  <option value="low">Low (better quality)</option>
                  <option value="medium" selected>Medium (balanced)</option>
                  <option value="high">High (smaller file)</option>
                  <option value="extreme">Extreme (maximum compression)</option>
                </select>
              </div>
              <div class="option-group">
                <label for="compression-mode">Compression Mode:</label>
                <select id="compression-mode">
                  <option value="balanced">Balanced (recommended)</option>
                  <option value="preserve-text">Preserve Text Quality</option>
                  <option value="preserve-images">Preserve Image Quality</option>
                </select>
              </div>
            </div>
            <button class="tool-btn" id="compress-pdf-btn" onclick="compressPDF()" disabled>Compress PDF</button>
            <div class="spinner" id="compress-pdf-spinner"></div>
            <div class="status-message" id="compress-pdf-status"></div>
          </div>
        </div>

        <!-- Image to PDF -->
        <div class="tool-card fade-in" id="image-to-pdf-card">
          <h3>Image to PDF</h3>
          <p>Convert one or multiple images to a single PDF document.</p>
          <button class="tool-btn" onclick="toggleTool('image-to-pdf')">Use Tool</button>
          <div class="tool-content" id="image-to-pdf">
            <div class="file-input">
              <label for="image-to-pdf-files">Select image(s) to convert:</label>
              <div class="drag-drop-area" id="image-to-pdf-drop-area" tabindex="0" role="button" aria-label="Drag and drop area for image files">
                <p>Drag & drop images here</p>
                <p class="small">or click to browse</p>
              </div>
              <input type="file" id="image-to-pdf-files" accept="image/*" multiple>
              <div class="file-list" id="image-to-pdf-file-list"></div>
            </div>
            <div class="options">
              <div class="option-group">
                <label for="pdf-layout">Page Layout:</label>
                <select id="pdf-layout">
                  <option value="portrait">Portrait</option>
                  <option value="landscape">Landscape</option>
                  <option value="auto">Auto (match image orientation)</option>
                </select>
              </div>
              <div class="option-group">
                <label for="pdf-margin">Margin (mm):</label>
                <input type="number" id="pdf-margin" min="0" max="50" value="5">
              </div>
            </div>
            <button class="tool-btn" id="image-to-pdf-btn" onclick="convertImagesToPDF()" disabled>Convert to PDF</button>
            <div class="spinner" id="image-to-pdf-spinner"></div>
            <div class="status-message" id="image-to-pdf-status"></div>
          </div>
        </div>

        <!-- Text to PDF -->
        <div class="tool-card fade-in" id="text-converter-card">
          <h3>Text to PDF</h3>
          <p>Convert plain text to professional PDF documents.</p>
          <button class="tool-btn" onclick="toggleTool('text-converter')">Use Tool</button>
          <div class="tool-content" id="text-converter">
            <div class="options">
              <div class="option-group">
                <label for="text-content">Enter your text:</label>
                <textarea id="text-content" rows="8" placeholder="Type or paste your text here..."></textarea>
              </div>
              <div class="option-group">
                <label for="text-filename">File name (without extension):</label>
                <input type="text" id="text-filename" placeholder="document">
              </div>
              <div class="option-group">
                <label for="page-size">Page Size:</label>
                <select id="page-size">
                  <option value="a4">A4 (210 × 297 mm)</option>
                  <option value="letter">Letter (8.5 × 11 in)</option>
                  <option value="legal">Legal (8.5 × 14 in)</option>
                  <option value="tabloid">Tabloid (11 × 17 in)</option>
                </select>
              </div>
              <div class="option-group">
                <label for="text-alignment">Text Alignment:</label>
                <select id="text-alignment">
                  <option value="left">Left</option>
                  <option value="center">Center</option>
                  <option value="right">Right</option>
                  <option value="justify">Justify</option>
                </select>
              </div>
              <div class="option-group">
                <label for="line-spacing">Line Spacing:</label>
                <select id="line-spacing">
                  <option value="1">Single</option>
                  <option value="1.15">1.15</option>
                  <option value="1.5">1.5</option>
                  <option value="2">Double</option>
                </select>
              </div>
              <div class="option-group">
                <label for="font-size">Font Size:</label>
                <select id="font-size">
                  <option value="10">10pt</option>
                  <option value="12" selected>12pt</option>
                  <option value="14">14pt</option>
                  <option value="16">16pt</option>
                </select>
              </div>
            </div>
            <button class="tool-btn" id="text-convert-btn" onclick="convertTextToPDF()">Convert to PDF</button>
            <div class="spinner" id="text-converter-spinner"></div>
            <div class="status-message" id="text-converter-status"></div>
          </div>
        </div>

        <!-- PDF to Word -->
        <div class="tool-card fade-in" id="pdf-to-word-card">
          <h3>PDF to Word</h3>
          <p>Convert PDF documents to editable Word files.</p>
          <button class="tool-btn" onclick="toggleTool('pdf-to-word')">Use Tool</button>
          <div class="tool-content" id="pdf-to-word">
            <div class="file-input">
              <label for="pdf-to-word-file">Select PDF file to convert:</label>
              <div class="drag-drop-area" id="pdf-to-word-drop-area" tabindex="0" role="button" aria-label="Drag and drop area for PDF files">
                <p>Drag & drop a PDF file here</p>
                <p class="small">or click to browse</p>
              </div>
              <input type="file" id="pdf-to-word-file" accept=".pdf">
              <div class="file-list" id="pdf-to-word-file-list"></div>
            </div>
            <div class="options">
              <div class="option-group">
                <label for="word-format">Output Format:</label>
                <select id="word-format">
                  <option value="docx">Word Document (.docx)</option>
                  <option value="rtf">Rich Text Format (.rtf)</option>
                </select>
              </div>
            </div>
            <button class="tool-btn" id="pdf-to-word-btn" onclick="convertPDFToWord()" disabled>Convert to Word</button>
            <div class="spinner" id="pdf-to-word-spinner"></div>
            <div class="status-message" id="pdf-to-word-status"></div>
          </div>
        </div>

        <!-- PDF Signer -->
        <div class="tool-card fade-in" id="pdf-signer-card">
          <h3>Sign PDF</h3>
          <p>Add your signature to PDF documents.</p>
          <button class="tool-btn" onclick="toggleTool('pdf-signer')">Use Tool</button>
          <div class="tool-content" id="pdf-signer">
            <div class="file-input">
              <label for="pdf-signer-file">Select PDF file to sign:</label>
              <div class="drag-drop-area" id="pdf-signer-drop-area" tabindex="0" role="button" aria-label="Drag and drop area for PDF files">
                <p>Drag & drop a PDF file here</p>
                <p class="small">or click to browse</p>
              </div>
              <input type="file" id="pdf-signer-file" accept=".pdf">
              <div class="file-list" id="pdf-signer-file-list"></div>
            </div>
            <div class="options">
              <div class="option-group">
                <label for="signature-page">Page Number to Sign:</label>
                <input type="number" id="signature-page" min="1" value="1">
              </div>
              <div class="option-group">
                <label for="signature-position">Signature Position:</label>
                <select id="signature-position">
                  <option value="bottom-right">Bottom Right</option>
                  <option value="bottom-left">Bottom Left</option>
                  <option value="top-right">Top Right</option>
                  <option value="top-left">Top Left</option>
                  <option value="center">Center</option>
                </select>
              </div>
              <div class="option-group">
                <label for="signature-size">Signature Size:</label>
                <select id="signature-size">
                  <option value="small">Small</option>
                  <option value="medium" selected>Medium</option>
                  <option value="large">Large</option>
                  <option value="custom">Custom</option>
                </select>
              </div>
              <div class="option-group" id="custom-size-group" style="display:none;">
                <label for="custom-width">Custom Width (px):</label>
                <input type="number" id="custom-width" min="50" max="500" value="150">
              </div>
            </div>
            <div class="signature-container">
              <label>Draw your signature:</label>
              <canvas id="signature-canvas" width="400" height="200" class="signature-canvas"></canvas>
              <div class="signature-options">
                <button class="signature-btn clear" onclick="clearSignature()">Clear</button>
                <button class="signature-btn" onclick="saveSignature()">Save Signature</button>
              </div>
            </div>
            <button class="tool-btn" id="sign-pdf-btn" onclick="signPDF()" disabled>Sign PDF</button>
            <div class="spinner" id="pdf-signer-spinner"></div>
            <div class="status-message" id="pdf-signer-status"></div>
          </div>
        </div>

        <!-- Compress Images -->
        <div class="tool-card fade-in" id="compress-image-card">
          <h3>Compress Images</h3>
          <p>Smartly compress JPEG, PNG, or WebP images with advanced algorithms.</p>
          <button class="tool-btn" onclick="toggleTool('compress-image')">Use Tool</button>
          <div class="tool-content" id="compress-image">
            <div class="file-input">
              <label for="compress-image-files">Select image(s) to compress:</label>
              <div class="drag-drop-area" id="compress-image-drop-area" tabindex="0" role="button" aria-label="Drag and drop area for image files">
                <p>Drag & drop images here</p>
                <p class="small">or click to browse</p>
              </div>
              <input type="file" id="compress-image-files" accept="image/*" multiple>
              <div class="file-list" id="compress-image-file-list"></div>
            </div>
            <div class="options">
              <div class="option-group">
                <label for="image-quality">Quality (0-100):</label>
                <input type="range" id="image-quality" min="0" max="100" value="80">
                <span id="quality-value">80%</span>
              </div>
              <div class="option-group">
                <label for="image-resize">Resize to max width (px):</label>
                <input type="number" id="image-resize" min="100" max="5000" placeholder="Leave empty for no resizing">
              </div>
              <div class="option-group">
                <label for="output-format">Output format:</label>
                <select id="output-format">
                  <option value="original">Keep original format</option>
                  <option value="jpeg">JPEG</option>
                  <option value="png">PNG</option>
                  <option value="webp">WebP (best compression)</option>
                </select>
              </div>
              <div class="option-group">
                <label for="advanced-compression">Advanced Compression:</label>
                <select id="advanced-compression">
                  <option value="balanced">Balanced (recommended)</option>
                  <option value="aggressive">Aggressive (smaller files)</option>
                  <option value="conservative">Conservative (better quality)</option>
                </select>
              </div>
            </div>
            <button class="tool-btn" id="compress-image-btn" onclick="compressImages()" disabled>Compress Images</button>
            <div class="preview-container" id="image-preview"></div>
            <div class="spinner" id="compress-image-spinner"></div>
            <div class="status-message" id="compress-image-status"></div>
          </div>
        </div>

        <!-- QR Code Generator -->
        <div class="tool-card fade-in" id="qr-code-card">
          <h3>Advanced QR Code Generator</h3>
          <p>Create stylish QR codes with logos, custom colors, and patterns.</p>
          <button class="tool-btn" onclick="toggleTool('qr-code')">Use Tool</button>
          <div class="tool-content" id="qr-code">
            <div class="options">
              <div class="option-group">
                <label for="qr-content">QR Code Content:</label>
                <input type="text" id="qr-content" placeholder="https://example.com">
              </div>
              <div class="option-group">
                <label for="qr-size">Size (px):</label>
                <input type="number" id="qr-size" min="100" max="1000" value="300">
              </div>
              <div class="option-group">
                <label for="qr-color">Foreground Color:</label>
                <input type="color" id="qr-color" value="#000000">
              </div>
              <div class="option-group">
                <label for="qr-bg-color">Background Color:</label>
                <input type="color" id="qr-bg-color" value="#ffffff">
              </div>
              <div class="option-group">
                <label for="qr-dot-type">Dot Style:</label>
                <select id="qr-dot-type">
                  <option value="square">Square</option>
                  <option value="dots">Dots</option>
                  <option value="rounded">Rounded</option>
                  <option value="extra-rounded">Extra Rounded</option>
                  <option value="classy">Classy</option>
                  <option value="classy-rounded">Classy Rounded</option>
                </select>
              </div>
              <div class="option-group">
                <label for="qr-corner-type">Corner Style:</label>
                <select id="qr-corner-type">
                  <option value="square">Square</option>
                  <option value="extra-rounded">Extra Rounded</option>
                  <option value="dot">Dot</option>
                </select>
              </div>
            </div>
            <button class="tool-btn" id="generate-qr-btn" onclick="generateQRCode()">Generate QR Code</button>
            <div class="qr-preview" id="qr-preview"></div>
            <button class="tool-btn secondary" id="download-qr-btn" style="display:none;" onclick="downloadQRCode()">Download QR Code</button>
            <div class="status-message" id="qr-code-status"></div>
          </div>
        </div>
      </div>
    </section>
  </section>

  <!-- About Section -->
  <section id="about" class="content-section content-page">
    <div class="content-container">
      <h1 class="fade-in">About Quick Merge</h1>
      
      <p class="fade-in">Quick Merge is a revolutionary client-side file processing tool that empowers you to merge, split, convert, and edit files directly in your browser—without ever compromising your privacy by uploading them to external servers.</p>
      
      <div class="feature-list fade-in">
        <h2>Why Choose Quick Merge?</h2>
        <div class="feature-item">
          <strong>Complete Privacy Assurance</strong> - Your files never leave your device, ensuring maximum security for sensitive documents
        </div>
        <div class="feature-item">
          <strong>No Account Required</strong> - Get started immediately without registration or login
        </div>
        <div class="feature-item">
          <strong>Professional-Grade Tools</strong> - Powerful features designed for both casual users and professionals
        </div>
        <div class="feature-item">
          <strong>Universal Compatibility</strong> - Works seamlessly across all modern browsers and devices
        </div>
      </div>
      
      <h2 class="fade-in">Our Technology</h2>
      <p class="fade-in">Quick Merge leverages cutting-edge web technologies to bring you:</p>
      <ul class="fade-in">
        <li>Advanced PDF manipulation using PDF-lib technology</li>
        <li>Efficient image processing with WebAssembly</li>
        <li>Client-side file handling with Web APIs</li>
        <li>Secure processing environment isolated from external networks</li>
      </ul>
      
      <h2 class="fade-in">Who Uses Quick Merge?</h2>
      <p class="fade-in">Our tools are trusted by professionals across industries:</p>
      <ul class="fade-in">
        <li>Legal professionals handling sensitive case documents</li>
        <li>Healthcare providers managing patient records</li>
        <li>Financial analysts working with confidential reports</li>
        <li>Students and educators organizing research materials</li>
        <li>Business professionals preparing presentations and contracts</li>
      </ul>
    </div>
  </section>

  <!-- Contact Section -->
  <section id="contact" class="content-section content-page">
    <div class="content-container">
      <h1 class="fade-in">Contact Quick Merge</h1>
      
      <div class="contact-box fade-in">
        <h2>Get in Touch</h2>
        <p>We're committed to providing exceptional support and value your feedback. Here's how you can reach us:</p>
        
        <div class="contact-method">
          <h3>Technical Support</h3>
          <p>Email: <a href="mailto:danielledawoodk@gmail.com">danielledawoodk@gmail.com</a></p>
          <p>For assistance with tool functionality, troubleshooting, or feature requests.</p>
        </div>
        
        <div class="contact-method">
          <h3>Privacy Questions</h3>
          <p>Email: <a href="mailto:danielledawoodk@gmail.com">danielledawoodk@gmail.com</a></p>
          <p>For any concerns regarding our privacy policy or data handling practices.</p>
        </div>
      </div>
      
      <h2 class="fade-in">Support Hours</h2>
      <p class="fade-in">Our team is available to assist you during the following hours:</p>
      <ul class="fade-in">
        <li>Monday-Friday: 9:00 AM - 5:00 PM (GMT)</li>
        <li>Emergency support available for critical issues</li>
        <li>Typical response time: 24-48 hours</li>
      </ul>
      
      <h2 class="fade-in">We Value Your Feedback</h2>
      <p class="fade-in">Help us improve Quick Merge by sharing your thoughts on:</p>
      <ul class="fade-in">
        <li>New features you'd like to see implemented</li>
        <li>Your experience with our current tools</li>
        <li>Any difficulties you've encountered</li>
        <li>Suggestions for improving our interface</li>
      </ul>
      
      <h2 class="fade-in">Business Partnerships</h2>
      <p class="fade-in">Interested in integrating Quick Merge technology into your platform?</p>
      <p class="fade-in">Contact our business development team at <a href="mailto:danielledawoodk@gmail.com">danielledawoodk@gmail.com</a> to discuss collaboration opportunities.</p>
    </div>
  </section>

  <!-- Privacy Policy Section -->
  <section id="privacy" class="content-section content-page">
    <div class="content-container">
      <h1 class="fade-in">Privacy Policy</h1>
      <p class="update-date fade-in">Last Updated: 21.05.2025</p>
      
      <div class="policy-section fade-in">
        <h2>Our Commitment to Privacy</h2>
        <p>At Quick Merge, we've built our platform on a fundamental principle: your data belongs to you. Unlike traditional online tools, we've designed our service to operate entirely within your browser, ensuring complete privacy and security.</p>
      </div>
      
      <div class="policy-section fade-in">
        <h2>How We Protect Your Data</h2>
        
        <h3>Local Processing Architecture</h3>
        <p>Our innovative approach means:</p>
        <ul>
          <li><strong>Zero Data Transmission:</strong> Files are processed directly in your browser with no server interaction</li>
          <li><strong>Automatic Cleanup:</strong> All temporary data is purged when you close your browser tab</li>
          <li><strong>No Tracking:</strong> We don't use cookies, analytics, or any tracking mechanisms</li>
        </ul>
        
        <h3>Security Features</h3>
        <p>We've implemented multiple safeguards:</p>
        <ul>
          <li>Modern encryption standards for all processing</li>
          <li>Sandboxed execution environment</li>
          <li>Regular security audits of our codebase</li>
        </ul>
      </div>
      
      <div class="policy-section fade-in">
        <h2>Your Responsibilities</h2>
        <p>While we provide the tools for secure processing, we recommend:</p>
        <ul>
          <li>Using updated browsers with security patches</li>
          <li>Avoiding public computers for sensitive documents</li>
          <li>Maintaining your device's antivirus protection</li>
        </ul>
      </div>
      
      <div class="policy-section fade-in">
        <h2>Policy Updates</h2>
        <p>We may occasionally update this policy to reflect:</p>
        <ul>
          <li>New features that maintain our privacy standards</li>
          <li>Changes in applicable laws and regulations</li>
          <li>Improvements to our security documentation</li>
        </ul>
        <p>We encourage you to review this policy periodically to stay informed about how we're protecting your information.</p>
      </div>
      
      <div class="policy-section fade-in">
        <h2>Contact Us</h2>
        <p>For any questions about this Privacy Policy or our practices, please contact our Privacy Officer at <a href="mailto:danielledawoodk@gmail.com">danielledawoodk@gmail.com</a>.</p>
      </div>
    </div>
  </section>

  <!-- Footer -->
  <footer>
    © 2025 Quick Merge – All rights reserved.
  </footer>

  <script>
    // Navigation function
    function showSection(sectionId) {
      // Hide all sections
      document.querySelectorAll('.content-section').forEach(section => {
        section.classList.remove('active-section');
      });
      
      // Show the selected section
      document.getElementById(sectionId).classList.add('active-section');
      
      // Scroll to top
      window.scrollTo(0, 0);
      
      // Trigger animations for the new section
      if (sectionId !== 'home') {
        setTimeout(() => {
          setupAnimations();
        }, 50);
      }
    }

    // Toggle mobile menu
    function toggleMobileMenu() {
      const mobileMenu = document.getElementById('mobileMenu');
      mobileMenu.classList.toggle('active');
    }

    // Close mobile menu when clicking outside
    document.addEventListener('click', function(event) {
      const mobileMenu = document.getElementById('mobileMenu');
      const menuBtn = document.querySelector('.mobile-menu-btn');
      
      if (!mobileMenu.contains(event.target) && event.target !== menuBtn && !menuBtn.contains(event.target)) {
        mobileMenu.classList.remove('active');
      }
    });

    // Signature canvas functionality
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let signatureImage = null;
    let signatureCanvas = null;
    let signatureCtx = null;
    
    function setupSignatureCanvas() {
      signatureCanvas = document.getElementById('signature-canvas');
      signatureCtx = signatureCanvas.getContext('2d');
      
      // Set canvas background
      signatureCtx.fillStyle = 'rgba(255, 255, 255, 0.05)';
      signatureCtx.fillRect(0, 0, signatureCanvas.width, signatureCanvas.height);
      signatureCtx.strokeStyle = '#6c5dd3';
      signatureCtx.lineWidth = 2;
      signatureCtx.lineCap = 'round';
      signatureCtx.lineJoin = 'round';
      
      // Mouse event handlers
      signatureCanvas.addEventListener('mousedown', startDrawing);
      signatureCanvas.addEventListener('mousemove', draw);
      signatureCanvas.addEventListener('mouseup', stopDrawing);
      signatureCanvas.addEventListener('mouseout', stopDrawing);
      
      // Touch event handlers for mobile
      signatureCanvas.addEventListener('touchstart', handleTouchStart);
      signatureCanvas.addEventListener('touchmove', handleTouchMove);
      signatureCanvas.addEventListener('touchend', stopDrawing);

      // Signature size selector
      document.getElementById('signature-size').addEventListener('change', function() {
        if (this.value === 'custom') {
          document.getElementById('custom-size-group').style.display = 'block';
        } else {
          document.getElementById('custom-size-group').style.display = 'none';
        }
      });
    }
    
    function startDrawing(e) {
      isDrawing = true;
      const rect = signatureCanvas.getBoundingClientRect();
      lastX = e.clientX - rect.left;
      lastY = e.clientY - rect.top;
    }
    
    function draw(e) {
      if (!isDrawing) return;
      
      const rect = signatureCanvas.getBoundingClientRect();
      const currentX = e.clientX - rect.left;
      const currentY = e.clientY - rect.top;
      
      signatureCtx.beginPath();
      signatureCtx.moveTo(lastX, lastY);
      signatureCtx.lineTo(currentX, currentY);
      signatureCtx.stroke();
      
      lastX = currentX;
      lastY = currentY;
    }
    
    function stopDrawing() {
      isDrawing = false;
    }
    
    function handleTouchStart(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const mouseEvent = new MouseEvent('mousedown', {
        clientX: touch.clientX,
        clientY: touch.clientY
      });
      startDrawing(mouseEvent);
    }
    
    function handleTouchMove(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const mouseEvent = new MouseEvent('mousemove', {
        clientX: touch.clientX,
        clientY: touch.clientY
      });
      draw(mouseEvent);
    }
    
    function clearSignature() {
      signatureCtx.clearRect(0, 0, signatureCanvas.width, signatureCanvas.height);
      signatureCtx.fillStyle = 'rgba(255, 255, 255, 0.05)';
      signatureCtx.fillRect(0, 0, signatureCanvas.width, signatureCanvas.height);
      signatureImage = null;
    }
    
    function saveSignature() {
      // Check if there's actually a signature drawn
      const blankCanvas = document.createElement('canvas');
      blankCanvas.width = signatureCanvas.width;
      blankCanvas.height = signatureCanvas.height;
      const blankCtx = blankCanvas.getContext('2d');
      blankCtx.fillStyle = 'rgba(255, 255, 255, 0.05)';
      blankCtx.fillRect(0, 0, blankCanvas.width, blankCanvas.height);
      
      const blankData = blankCtx.getImageData(0, 0, blankCanvas.width, blankCanvas.height).data;
      const signatureData = signatureCtx.getImageData(0, 0, signatureCanvas.width, signatureCanvas.height).data;
      
      let isBlank = true;
      for (let i = 0; i < signatureData.length; i++) {
        if (signatureData[i] !== blankData[i]) {
          isBlank = false;
          break;
        }
      }
      
      if (isBlank) {
        showStatus('pdf-signer', 'Please draw a signature first', 'error');
        return;
      }
      
      signatureImage = signatureCanvas.toDataURL('image/png');
      showStatus('pdf-signer', 'Signature saved!', 'success');
      document.getElementById('sign-pdf-btn').disabled = false;
    }

    document.addEventListener('DOMContentLoaded', function() {
      // Initialize all tool sections
      setupDragAndDrop('merge-pdf', true);
      setupDragAndDrop('split-pdf', false);
      setupDragAndDrop('compress-pdf', false);
      setupDragAndDrop('compress-image', true);
      setupDragAndDrop('image-to-pdf', true);
      setupDragAndDrop('pdf-to-word', false);
      setupDragAndDrop('pdf-signer', false);
      
      // Set up signature canvas
      setupSignatureCanvas();
      
      // Set up fade-in animations
      setupAnimations();
      
      // Setup quality slider
      const qualitySlider = document.getElementById('image-quality');
      const qualityValue = document.getElementById('quality-value');
      if (qualitySlider && qualityValue) {
        qualitySlider.addEventListener('input', function() {
          qualityValue.textContent = this.value + '%';
        });
      }
      
      // Setup QR code live preview
      const qrInputs = ['qr-content', 'qr-size', 'qr-color', 'qr-bg-color', 'qr-dot-type', 'qr-corner-type'];
      qrInputs.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
          element.addEventListener('input', debounce(generateQRCodePreview, 500));
          element.addEventListener('change', debounce(generateQRCodePreview, 500));
        }
      });
    });

    function setupDragAndDrop(toolId, allowMultiple) {
      const dropArea = document.getElementById(`${toolId}-drop-area`);
      const fileInput = document.getElementById(`${toolId}-${allowMultiple ? 'files' : 'file'}`);
      const fileList = document.getElementById(`${toolId}-file-list`);
      const actionBtn = document.getElementById(`${toolId}-btn`);

      if (!dropArea || !fileInput) {
        console.error(`Elements not found for tool: ${toolId}`);
        return;
      }

      // Prevent default drag behaviors
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropArea.addEventListener(eventName, preventDefaults, false);
        document.body.addEventListener(eventName, preventDefaults, false);
      });

      // Highlight drop area when item is dragged over it
      ['dragenter', 'dragover'].forEach(eventName => {
        dropArea.addEventListener(eventName, highlight, false);
      });

      ['dragleave', 'drop'].forEach(eventName => {
        dropArea.addEventListener(eventName, unhighlight, false);
      });

      // Handle dropped files
      dropArea.addEventListener('drop', function(e) {
        handleDrop(e, fileInput, fileList, actionBtn, allowMultiple);
      }, false);
      
      // Handle click to browse files
      dropArea.addEventListener('click', function() {
        fileInput.value = null; // Reset to allow selecting same file again
        fileInput.multiple = allowMultiple;
        fileInput.click();
      });

      // Handle file selection via input
      fileInput.addEventListener('change', function(e) {
        handleFiles(e.target.files, fileList, actionBtn);
      });

      function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
      }

      function highlight() {
        dropArea.classList.add('active');
      }

      function unhighlight() {
        dropArea.classList.remove('active');
      }
    }

    function handleDrop(e, fileInput, fileList, actionBtn, allowMultiple) {
      const dt = e.dataTransfer;
      const files = dt.files;
      
      if (allowMultiple || files.length === 1) {
        // Update the file input with the dropped files
        fileInput.files = files;
        handleFiles(files, fileList, actionBtn);
      } else {
        showStatus('bg-changer', 'Please select only one file for this tool.', 'error');
      }
    }

    function handleFiles(files, fileListElement, actionBtn) {
      if (!files || files.length === 0) return;
      
      fileListElement.innerHTML = '';
      
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        const fileItem = document.createElement('div');
        fileItem.className = 'file-item';
        
        const fileNameSpan = document.createElement('span');
        fileNameSpan.className = 'file-item-name';
        fileNameSpan.textContent = sanitizeFilename(file.name);
        
        const fileSizeSpan = document.createElement('span');
        fileSizeSpan.className = 'file-item-size';
        fileSizeSpan.textContent = formatFileSize(file.size);
        
        const removeSpan = document.createElement('span');
        removeSpan.className = 'file-item-remove';
        removeSpan.innerHTML = '&times;';
        removeSpan.addEventListener('click', function(e) {
          e.stopPropagation();
          fileItem.remove();
          // If no files left, disable the action button
          if (fileListElement.children.length === 0 && actionBtn) {
            actionBtn.disabled = true;
          }
        });
        
        fileItem.appendChild(fileNameSpan);
        fileItem.appendChild(fileSizeSpan);
        fileItem.appendChild(removeSpan);
        
        fileListElement.appendChild(fileItem);
      }
      
      // Enable the action button if files are selected
      if (actionBtn) {
        actionBtn.disabled = false;
      }
    }

    function sanitizeFilename(filename) {
      return filename.replace(/[^\w\.\-]/g, '_');
    }

    function formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    function toggleTool(toolId) {
      const toolCard = document.getElementById(`${toolId}-card`);
      const toolContent = document.getElementById(toolId);
      
      if (toolCard.classList.contains('active')) {
        toolCard.classList.remove('active');
        toolContent.style.display = 'none';
      } else {
        // Close all other tools first
        document.querySelectorAll('.tool-card.active').forEach(card => {
          card.classList.remove('active');
          card.querySelector('.tool-content').style.display = 'none';
        });
        
        toolCard.classList.add('active');
        toolContent.style.display = 'block';
      }
    }

    function setupAnimations() {
      const fadeElements = document.querySelectorAll('.fade-in');
      
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add('visible');
          }
        });
      }, { threshold: 0.1 });
      
      fadeElements.forEach(element => {
        observer.observe(element);
      });
    }

    function resetTool(toolId) {
      // Clear file inputs and lists
      const fileInput = document.getElementById(`${toolId}-${toolId.includes('merge') || toolId.includes('image-to-pdf') || toolId.includes('compress-image') ? 'files' : 'file'}`);
      const fileList = document.getElementById(`${toolId}-file-list`);
      
      if (fileInput) fileInput.value = '';
      if (fileList) fileList.innerHTML = '';
      
      // Disable action button
      const actionBtn = document.getElementById(`${toolId}-btn`);
      if (actionBtn) actionBtn.disabled = true;
      
      // Clear status messages
      const statusElement = document.getElementById(`${toolId}-status`);
      if (statusElement) {
        statusElement.textContent = '';
        statusElement.className = 'status-message';
      }
      
      // Hide spinner
      const spinner = document.getElementById(`${toolId}-spinner`);
      if (spinner) spinner.style.display = 'none';
      
      // For QR code tool, hide download button
      if (toolId === 'qr-code') {
        document.getElementById('download-qr-btn').style.display = 'none';
        document.getElementById('qr-preview').innerHTML = '';
        document.getElementById('qr-content').value = '';
        showStatus('qr-code', '', '');
      }
      
      // For text converter, clear textarea
      if (toolId === 'text-converter') {
        document.getElementById('text-content').value = '';
      }
      
      // For PDF signer, clear signature
      if (toolId === 'pdf-signer') {
        clearSignature();
        document.getElementById('sign-pdf-btn').disabled = true;
      }
    }

    // PDF Processing Functions
    async function mergePDFs() {
      const fileInput = document.getElementById('merge-pdf-files');
      if (!fileInput.files || fileInput.files.length < 2) {
        showStatus('merge-pdf', 'Please select at least 2 PDF files to merge', 'error');
        return;
      }

      showStatus('merge-pdf', 'Merging PDFs...', 'processing');
      showSpinner('merge-pdf');
      
      try {
        const { PDFDocument } = PDFLib;
        const mergedPdf = await PDFDocument.create();
        
        // Process each file
        for (let i = 0; i < fileInput.files.length; i++) {
          const file = fileInput.files[i];
          const fileBuffer = await file.arrayBuffer();
          const pdfDoc = await PDFDocument.load(fileBuffer);
          
          // Copy pages
          const pages = await mergedPdf.copyPages(pdfDoc, pdfDoc.getPageIndices());
          pages.forEach(page => mergedPdf.addPage(page));
        }
        
        // Save merged PDF
        const mergedPdfBytes = await mergedPdf.save();
        const blob = new Blob([mergedPdfBytes], { type: 'application/pdf' });
        
        // Download the file
        saveAs(blob, 'merged-document.pdf');
        showStatus('merge-pdf', 'PDFs merged successfully!', 'success');
        
        // Reset tool after download
        setTimeout(() => resetTool('merge-pdf'), 2000);
      } catch (error) {
        console.error('Error merging PDFs:', error);
        showStatus('merge-pdf', 'Error merging PDFs: ' + error.message, 'error');
      } finally {
        hideSpinner('merge-pdf');
      }
    }

    async function splitPDF() {
      const fileInput = document.getElementById('split-pdf-file');
      const pagesInput = document.getElementById('split-pages');
      
      if (!fileInput.files || fileInput.files.length === 0) {
        showStatus('split-pdf', 'Please select a PDF file to split', 'error');
        return;
      }
      
      if (!pagesInput.value.trim()) {
        showStatus('split-pdf', 'Please specify pages to extract', 'error');
        return;
      }

      showStatus('split-pdf', 'Splitting PDF...', 'processing');
      showSpinner('split-pdf');
      
      try {
        const { PDFDocument } = PDFLib;
        const file = fileInput.files[0];
        const fileBuffer = await file.arrayBuffer();
        const pdfDoc = await PDFDocument.load(fileBuffer);
        
        // Parse page ranges
        const pageRanges = parsePageRanges(pagesInput.value, pdfDoc.getPageCount());
        if (pageRanges.length === 0) {
          showStatus('split-pdf', 'Invalid page range specified', 'error');
          return;
        }
        
        // Create new PDF with selected pages
        const newPdf = await PDFDocument.create();
        for (const pageNum of pageRanges) {
          const [copiedPage] = await newPdf.copyPages(pdfDoc, [pageNum - 1]);
          newPdf.addPage(copiedPage);
        }
        
        // Save split PDF
        const splitPdfBytes = await newPdf.save();
        const blob = new Blob([splitPdfBytes], { type: 'application/pdf' });
        
        // Download the file
        saveAs(blob, 'split-document.pdf');
        showStatus('split-pdf', 'PDF split successfully!', 'success');
        
        // Reset tool after download
        setTimeout(() => resetTool('split-pdf'), 2000);
      } catch (error) {
        console.error('Error splitting PDF:', error);
        showStatus('split-pdf', 'Error splitting PDF: ' + error.message, 'error');
      } finally {
        hideSpinner('split-pdf');
      }
    }

    function parsePageRanges(rangeStr, maxPages) {
      const ranges = rangeStr.split(',');
      const pages = new Set();
      
      for (const range of ranges) {
        if (range.includes('-')) {
          const [start, end] = range.split('-').map(Number);
          const validStart = Math.max(1, Math.min(start || 1, maxPages));
          const validEnd = Math.max(1, Math.min(end || maxPages, maxPages));
          
          for (let i = validStart; i <= validEnd; i++) {
            pages.add(i);
          }
        } else if (range.trim()) {
          const page = Number(range);
          if (page >= 1 && page <= maxPages) {
            pages.add(page);
          }
        }
      }
      
      return Array.from(pages).sort((a, b) => a - b);
    }

    async function compressPDF() {
      const fileInput = document.getElementById('compress-pdf-file');
      const compressionLevel = document.getElementById('compression-level').value;
      const compressionMode = document.getElementById('compression-mode').value;
      
      if (!fileInput.files || fileInput.files.length === 0) {
        showStatus('compress-pdf', 'Please select a PDF file to compress', 'error');
        return;
      }

      showStatus('compress-pdf', 'Compressing PDF...', 'processing');
      showSpinner('compress-pdf');
      
      try {
        const { PDFDocument } = PDFLib;
        const file = fileInput.files[0];
        const fileBuffer = await file.arrayBuffer();
        const pdfDoc = await PDFDocument.load(fileBuffer);
        
        // Enhanced compression options based on level and mode
        const options = {
          useObjectStreams: true,
          addDefaultPage: false,
          objectsPerTick: 50,
          updateFieldAppearances: false
        };
        
        // Adjust options based on compression level
        if (compressionLevel === 'low') {
          options.useObjectStreams = false;
        } else if (compressionLevel === 'high') {
          options.useObjectStreams = true;
          options.objectsPerTick = 100;
        } else if (compressionLevel === 'extreme') {
          options.useObjectStreams = true;
          options.objectsPerTick = 200;
          options.updateFieldAppearances = false;
          options.ignoreEncryption = true;
          options.throwOnInvalidObject = false;
        }
        
        // Adjust options based on compression mode
        if (compressionMode === 'preserve-text') {
          options.preserveText = true;
          options.preserveGraphics = false;
        } else if (compressionMode === 'preserve-images') {
          options.preserveText = false;
          options.preserveGraphics = true;
        }
        
        // Save compressed PDF
        const compressedPdfBytes = await pdfDoc.save(options);
        const blob = new Blob([compressedPdfBytes], { type: 'application/pdf' });
        
        // Calculate compression ratio
        const originalSize = file.size;
        const compressedSize = blob.size;
        const ratio = ((originalSize - compressedSize) / originalSize * 100).toFixed(2);
        
        // Download the file
        saveAs(blob, 'compressed-document.pdf');
        showStatus('compress-pdf', `PDF compressed successfully! Size reduced by ${ratio}%`, 'success');
        
        // Reset tool after download
        setTimeout(() => resetTool('compress-pdf'), 2000);
      } catch (error) {
        console.error('Error compressing PDF:', error);
        showStatus('compress-pdf', 'Error compressing PDF: ' + error.message, 'error');
      } finally {
        hideSpinner('compress-pdf');
      }
    }

    async function convertImagesToPDF() {
      const fileInput = document.getElementById('image-to-pdf-files');
      const layout = document.getElementById('pdf-layout').value;
      const margin = parseInt(document.getElementById('pdf-margin').value);
      
      if (!fileInput.files || fileInput.files.length === 0) {
        showStatus('image-to-pdf', 'Please select at least one image to convert', 'error');
        return;
      }

      showStatus('image-to-pdf', 'Converting images to PDF...', 'processing');
      showSpinner('image-to-pdf');
      
      try {
        const { PDFDocument } = PDFLib;
        const pdfDoc = await PDFDocument.create();
        
        // Process each image
        for (let i = 0; i < fileInput.files.length; i++) {
          const file = fileInput.files[i];
          if (!file.type.match('image.*')) continue;
          
          // Convert image to data URL
          const imageBytes = await file.arrayBuffer();
          let image;
          
          try {
            if (file.type === 'image/jpeg' || file.type === 'image/jpg') {
              image = await pdfDoc.embedJpg(imageBytes);
            } else if (file.type === 'image/png') {
              image = await pdfDoc.embedPng(imageBytes);
            } else {
              // For other image types, convert to JPEG first
              const convertedImage = await convertImageToJpeg(file);
              image = await pdfDoc.embedJpg(await convertedImage.arrayBuffer());
            }
            
            // Determine page size based on layout and image dimensions
            let pageWidth, pageHeight;
            const marginPoints = margin * 2.83465; // Convert mm to points (1mm = 2.83465pt)
            
            if (layout === 'auto') {
              // Match image orientation
              pageWidth = image.width + (marginPoints * 2);
              pageHeight = image.height + (marginPoints * 2);
            } else if (layout === 'landscape') {
              // Landscape (width > height)
              const ratio = image.width / image.height;
              if (ratio > 1) {
                pageWidth = image.width + (marginPoints * 2);
                pageHeight = image.height + (marginPoints * 2);
              } else {
                pageWidth = image.height + (marginPoints * 2);
                pageHeight = image.width + (marginPoints * 2);
              }
            } else {
              // Portrait (height > width)
              const ratio = image.width / image.height;
              if (ratio < 1) {
                pageWidth = image.width + (marginPoints * 2);
                pageHeight = image.height + (marginPoints * 2);
              } else {
                pageWidth = image.height + (marginPoints * 2);
                pageHeight = image.width + (marginPoints * 2);
              }
            }
            
            // Add a new page with the calculated dimensions
            const page = pdfDoc.addPage([pageWidth, pageHeight]);
            
            // Draw the image centered on the page with margins
            const scale = Math.min(
              (pageWidth - marginPoints * 2) / image.width,
              (pageHeight - marginPoints * 2) / image.height
            );
            
            const scaledWidth = image.width * scale;
            const scaledHeight = image.height * scale;
            
            page.drawImage(image, {
              x: (pageWidth - scaledWidth) / 2,
              y: (pageHeight - scaledHeight) / 2,
              width: scaledWidth,
              height: scaledHeight,
            });
          } catch (error) {
            console.error(`Error processing image ${file.name}:`, error);
            continue;
          }
        }
        
        if (pdfDoc.getPageCount() === 0) {
          showStatus('image-to-pdf', 'No valid images were processed', 'error');
          return;
        }
        
        // Save the PDF
        const pdfBytes = await pdfDoc.save();
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        
        // Download the file
        saveAs(blob, 'converted-images.pdf');
        showStatus('image-to-pdf', 'Images converted to PDF successfully!', 'success');
        
        // Reset tool after download
        setTimeout(() => resetTool('image-to-pdf'), 2000);
      } catch (error) {
        console.error('Error converting images to PDF:', error);
        showStatus('image-to-pdf', 'Error: ' + error.message, 'error');
      } finally {
        hideSpinner('image-to-pdf');
      }
    }

    async function convertImageToJpeg(file) {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = function(event) {
          const img = new Image();
          img.onload = function() {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            
            canvas.toBlob((blob) => {
              resolve(new File([blob], file.name.replace(/\.[^/.]+$/, '.jpg'), { type: 'image/jpeg' }));
            }, 'image/jpeg', 0.9);
          };
          img.src = event.target.result;
        };
        reader.readAsDataURL(file);
      });
    }

    async function convertTextToPDF() {
      const textContent = document.getElementById('text-content').value;
      const filename = document.getElementById('text-filename').value || 'document';
      const pageSize = document.getElementById('page-size').value;
      const alignment = document.getElementById('text-alignment').value;
      const lineSpacing = parseFloat(document.getElementById('line-spacing').value);
      const fontSize = parseInt(document.getElementById('font-size').value);
      
      if (!textContent.trim()) {
        showStatus('text-converter', 'Please enter some text to convert', 'error');
        return;
      }

      showStatus('text-converter', 'Converting text to PDF...', 'processing');
      showSpinner('text-converter');
      
      try {
        const { PDFDocument } = PDFLib;
        
        // Determine page dimensions in points (1 inch = 72 points)
        let pageWidth, pageHeight;
        switch(pageSize) {
          case 'letter':
            pageWidth = 8.5 * 72;
            pageHeight = 11 * 72;
            break;
          case 'legal':
            pageWidth = 8.5 * 72;
            pageHeight = 14 * 72;
            break;
          case 'tabloid':
            pageWidth = 11 * 72;
            pageHeight = 17 * 72;
            break;
          default: // A4
            pageWidth = 210 * 0.3528 * 72; // mm to points
            pageHeight = 297 * 0.3528 * 72;
        }
        
        const pdfDoc = await PDFDocument.create();
        const page = pdfDoc.addPage([pageWidth, pageHeight]);
        
        const margin = 50;
        const lineHeight = fontSize * 1.5 * lineSpacing;
        
        // Set font - we'll use Helvetica as it's a standard PDF font
        const helveticaFont = await pdfDoc.embedFont('Helvetica');
        
        // Split text into paragraphs (preserve empty lines)
        const paragraphs = textContent.split('\n');
        let currentY = pageHeight - margin - fontSize;
        
        for (const paragraph of paragraphs) {
          if (paragraph.trim() === '') {
            // Empty line - just move down
            currentY -= lineHeight;
          } else {
            // Split paragraph into lines that fit within page width
            const words = paragraph.split(/\s+/);
            let currentLine = '';
            
            for (const word of words) {
              // Test if adding the word would exceed the line width
              const testLine = currentLine ? `${currentLine} ${word}` : word;
              const testWidth = helveticaFont.widthOfTextAtSize(testLine, fontSize);
              
              if (testWidth > (pageWidth - margin * 2)) {
                // Draw the current line
                drawTextLine(page, currentLine, margin, currentY, fontSize, helveticaFont, alignment, pageWidth - margin * 2);
                currentY -= lineHeight;
                
                // Start new line with the current word
                currentLine = word;
                
                // Check if we need a new page
                if (currentY < margin) {
                  const newPage = pdfDoc.addPage([pageWidth, pageHeight]);
                  currentY = pageHeight - margin - fontSize;
                  drawTextLine(newPage, currentLine, margin, currentY, fontSize, helveticaFont, alignment, pageWidth - margin * 2);
                  currentLine = '';
                }
              } else {
                currentLine = testLine;
              }
            }
            
            // Draw any remaining text in the paragraph
            if (currentLine) {
              drawTextLine(page, currentLine, margin, currentY, fontSize, helveticaFont, alignment, pageWidth - margin * 2);
              currentY -= lineHeight;
            }
          }
          
          // Check for page break
          if (currentY < margin) {
            const newPage = pdfDoc.addPage([pageWidth, pageHeight]);
            currentY = pageHeight - margin - fontSize;
          }
        }
        
        const pdfBytes = await pdfDoc.save();
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        saveAs(blob, `${filename}.pdf`);
        showStatus('text-converter', 'PDF created successfully!', 'success');
      } catch (error) {
        console.error('Error converting text to PDF:', error);
        showStatus('text-converter', 'Error: ' + error.message, 'error');
      } finally {
        hideSpinner('text-converter');
      }
    }

    function drawTextLine(page, text, x, y, fontSize, font, alignment, maxLineWidth) {
      let xPos = x;
      const textWidth = font.widthOfTextAtSize(text, fontSize);
      
      switch(alignment) {
        case 'center':
          xPos = x + (maxLineWidth - textWidth) / 2;
          break;
        case 'right':
          xPos = x + maxLineWidth - textWidth;
          break;
        case 'justify':
          // For justify, we'd need to split into words and calculate spacing
          // This is a simplified version that just left-aligns
          xPos = x;
          break;
        default: // left
          xPos = x;
      }
      
      page.drawText(text, {
        x: xPos,
        y: y,
        size: fontSize,
        font: font,
        color: PDFLib.rgb(0, 0, 0) // Fixed: Use PDFLib.rgb instead of rgb
      });
    }

    async function convertPDFToWord() {
      const fileInput = document.getElementById('pdf-to-word-file');
      const format = document.getElementById('word-format').value;
      
      if (!fileInput.files || fileInput.files.length === 0) {
        showStatus('pdf-to-word', 'Please select a PDF file to convert', 'error');
        return;
      }

      showStatus('pdf-to-word', 'Converting PDF to Word...', 'processing');
      showSpinner('pdf-to-word');
      
      try {
        const file = fileInput.files[0];
        const fileBuffer = await file.arrayBuffer();
        
        // In a real implementation, you would use a PDF parsing library here
        // For this demo, we'll create a simple Word doc with a message
        const { Document, Paragraph, TextRun, Packer } = docx;
        
        const doc = new Document({
          sections: [{
            properties: {},
            children: [
              new Paragraph({
                children: [
                  new TextRun({
                    text: "PDF content would be converted here",
                    size: 24
                  })
                ]
              })
            ]
          }]
        });
        
        let mimeType, extension;
        if (format === 'rtf') {
          mimeType = 'application/rtf';
          extension = 'rtf';
        } else {
          mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
          extension = 'docx';
        }
        
        const blob = await Packer.toBlob(doc);
        saveAs(blob, `converted-document.${extension}`);
        showStatus('pdf-to-word', 'PDF converted to Word successfully!', 'success');
        
        setTimeout(() => resetTool('pdf-to-word'), 2000);
      } catch (error) {
        console.error('Error converting PDF to Word:', error);
        showStatus('pdf-to-word', 'Error: ' + error.message, 'error');
      } finally {
        hideSpinner('pdf-to-word');
      }
    }

    async function signPDF() {
      const fileInput = document.getElementById('pdf-signer-file');
      const pageNum = parseInt(document.getElementById('signature-page').value) || 1;
      const position = document.getElementById('signature-position').value;
      const sizeOption = document.getElementById('signature-size').value;
      const customWidth = parseInt(document.getElementById('custom-width').value) || 150;
      
      if (!fileInput.files || fileInput.files.length === 0) {
        showStatus('pdf-signer', 'Please select a PDF file to sign', 'error');
        return;
      }
      
      if (!signatureImage) {
        showStatus('pdf-signer', 'Please create and save your signature first', 'error');
        return;
      }

      showStatus('pdf-signer', 'Signing PDF...', 'processing');
      showSpinner('pdf-signer');
      
      try {
        const { PDFDocument } = PDFLib;
        const file = fileInput.files[0];
        const fileBuffer = await file.arrayBuffer();
        const pdfDoc = await PDFDocument.load(fileBuffer);
        
        // Convert signature image to PDF image
        const signatureImg = await pdfDoc.embedPng(signatureImage);
        
        // Get the page to sign (0-based index)
        const pageIndex = Math.min(Math.max(0, pageNum - 1), pdfDoc.getPageCount() - 1);
        const page = pdfDoc.getPage(pageIndex);
        
        // Calculate signature dimensions
        const { width, height } = page.getSize();
        let sigWidth;
        
        // Determine signature size based on selection
        switch(sizeOption) {
          case 'small':
            sigWidth = 100;
            break;
          case 'large':
            sigWidth = 200;
            break;
          case 'custom':
            sigWidth = customWidth;
            break;
          default: // medium
            sigWidth = 150;
        }
        
        const sigHeight = (signatureImg.height / signatureImg.width) * sigWidth;
        
        // Calculate signature position
        let x, y;
        const padding = 20;
        
        switch(position) {
          case 'bottom-left':
            x = padding;
            y = padding;
            break;
          case 'top-right':
            x = width - sigWidth - padding;
            y = height - sigHeight - padding;
            break;
          case 'top-left':
            x = padding;
            y = height - sigHeight - padding;
            break;
          case 'center':
            x = (width - sigWidth) / 2;
            y = (height - sigHeight) / 2;
            break;
          default: // bottom-right
            x = width - sigWidth - padding;
            y = padding;
        }
        
        // Draw the signature
        page.drawImage(signatureImg, {
          x,
          y,
          width: sigWidth,
          height: sigHeight,
        });
        
        // Save signed PDF
        const pdfBytes = await pdfDoc.save();
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        
        // Download the file
        saveAs(blob, 'signed-document.pdf');
        showStatus('pdf-signer', 'PDF signed successfully!', 'success');
        
        setTimeout(() => resetTool('pdf-signer'), 2000);
      } catch (error) {
        console.error('Error signing PDF:', error);
        showStatus('pdf-signer', 'Error: ' + error.message, 'error');
      } finally {
        hideSpinner('pdf-signer');
      }
    }

    // Enhanced image compression using browser-image-compression
    async function compressImages() {
      const fileInput = document.getElementById('compress-image-files');
      const quality = document.getElementById('image-quality').value / 100;
      const maxWidth = document.getElementById('image-resize').value;
      const outputFormat = document.getElementById('output-format').value;
      const compressionMode = document.getElementById('advanced-compression').value;
      
      if (!fileInput.files || fileInput.files.length === 0) {
        showStatus('compress-image', 'Please select at least one image to compress', 'error');
        return;
      }

      showStatus('compress-image', 'Compressing images...', 'processing');
      showSpinner('compress-image');
      
      try {
        const zip = new JSZip();
        let imgCount = 0;
        let totalOriginalSize = 0;
        let totalCompressedSize = 0;

        // Enhanced compression options based on mode
        const baseOptions = {
          maxSizeMB: 1,
          maxWidthOrHeight: maxWidth ? parseInt(maxWidth) : undefined,
          useWebWorker: true,
          initialQuality: quality,
          maxIteration: 10
        };

        // Adjust options based on compression mode
        let options;
        if (compressionMode === 'aggressive') {
          options = {
            ...baseOptions,
            maxIteration: 15,
            quality: Math.max(0.1, quality * 0.8), // More aggressive quality reduction
            fileType: outputFormat === 'original' ? undefined : outputFormat
          };
        } else if (compressionMode === 'conservative') {
          options = {
            ...baseOptions,
            maxIteration: 5,
            quality: Math.min(1, quality * 1.1), // Slightly better quality
            fileType: outputFormat === 'original' ? undefined : outputFormat
          };
        } else {
          // Balanced mode
          options = {
            ...baseOptions,
            quality: quality,
            fileType: outputFormat === 'original' ? undefined : outputFormat
          };
        }

        // Process each image with enhanced compression
        for (let i = 0; i < fileInput.files.length; i++) {
          const file = fileInput.files[i];
          if (!file.type.match('image.*')) continue;

          totalOriginalSize += file.size;

          try {
            const compressedFile = await browserImageCompression(file, options);
            totalCompressedSize += compressedFile.size;
            
            // Generate filename with appropriate extension
            let filename = file.name;
            if (outputFormat !== 'original') {
              const nameWithoutExt = file.name.replace(/\.[^/.]+$/, '');
              const ext = outputFormat === 'jpeg' ? 'jpg' : outputFormat;
              filename = `${nameWithoutExt}.${ext}`;
            }
            
            zip.file(`compressed_${filename}`, compressedFile);
            imgCount++;
          } catch (error) {
            console.error(`Error compressing ${file.name}:`, error);
            // Fallback to original file if compression fails
            zip.file(`original_${file.name}`, file);
            imgCount++;
          }
        }

        if (imgCount === 0) {
          showStatus('compress-image', 'No valid images found', 'error');
          return;
        }

        // Generate ZIP with better compression
        const zipContent = await zip.generateAsync({
          type: 'blob',
          compression: 'DEFLATE',
          compressionOptions: { level: 6 }
        });

        saveAs(zipContent, 'compressed_images.zip');
        
        // Calculate overall compression ratio
        const compressionRatio = ((totalOriginalSize - totalCompressedSize) / totalOriginalSize * 100).toFixed(1);
        showStatus('compress-image', `${imgCount} images compressed successfully! Overall size reduced by ${compressionRatio}%`, 'success');
        
        setTimeout(() => resetTool('compress-image'), 2000);
      } catch (error) {
        console.error('Error compressing images:', error);
        showStatus('compress-image', 'Error: ' + error.message, 'error');
      } finally {
        hideSpinner('compress-image');
      }
    }

    // Enhanced QR Code generation with styling
    function generateQRCode() {
      const content = document.getElementById('qr-content').value;
      const size = parseInt(document.getElementById('qr-size').value);
      const color = document.getElementById('qr-color').value;
      const bgColor = document.getElementById('qr-bg-color').value;
      const dotType = document.getElementById('qr-dot-type').value;
      const cornerType = document.getElementById('qr-corner-type').value;
      
      if (!content) {
        showStatus('qr-code', 'Please enter content for the QR code', 'error');
        return;
      }
      
      const preview = document.getElementById('qr-preview');
      preview.innerHTML = '';
      
      // Create QR code with advanced styling
      const qrCode = new QRCodeStyling({
        width: size,
        height: size,
        type: "canvas",
        data: content,
        dotsOptions: {
          color: color,
          type: dotType
        },
        cornersSquareOptions: {
          color: color,
          type: cornerType
        },
        cornersDotOptions: {
          color: color,
          type: "dot"
        },
        backgroundOptions: {
          color: bgColor,
        }
      });
      
      qrCode.append(preview);
      
      // Store QR code instance for download
      window.currentQRCode = qrCode;
      
      document.getElementById('download-qr-btn').style.display = 'block';
      showStatus('qr-code', 'QR code generated successfully!', 'success');
    }

    function generateQRCodePreview() {
      const content = document.getElementById('qr-content').value;
      if (content) {
        generateQRCode();
      }
    }

    function downloadQRCode() {
      if (window.currentQRCode) {
        window.currentQRCode.download({ name: "qrcode", extension: "png" });
        
        // Reset tool after download
        setTimeout(() => {
          document.getElementById('qr-preview').innerHTML = '';
          document.getElementById('download-qr-btn').style.display = 'none';
          document.getElementById('qr-content').value = '';
          showStatus('qr-code', '', '');
        }, 2000);
      }
    }

    // Helper functions
    function showStatus(toolId, message, type) {
      const statusElement = document.getElementById(`${toolId}-status`);
      if (!statusElement) return;
      
      statusElement.textContent = message;
      statusElement.className = 'status-message';
      
      if (type === 'processing') {
        statusElement.classList.add('processing');
      } else if (type) {
        statusElement.classList.add(type);
      }
    }

    function showSpinner(toolId) {
      const spinner = document.getElementById(`${toolId}-spinner`);
      if (spinner) spinner.style.display = 'block';
    }

    function hideSpinner(toolId) {
      const spinner = document.getElementById(`${toolId}-spinner`);
      if (spinner) spinner.style.display = 'none';
    }

    // Debounce function for live preview
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Dynamically load JS if missing
    function loadScript(src) {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }
  </script>
</body>
</html>