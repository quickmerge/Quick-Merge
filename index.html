<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quick Merge â€“ Merge, Compress & Convert Files Instantly</title>
  <meta name="description" content="Quick Merge offers fast, secure file processing tools including PDF merging, splitting, compression, image conversion, and QR code generation - all processed locally in your browser.">
  <meta name="keywords" content="PDF merge, PDF split, compress PDF, image to PDF, QR code generator, file converter, online tools, privacy-focused tools">
  <meta name="author" content="Quick Merge">
  <meta name="robots" content="index, follow">
  <meta property="og:title" content="Quick Merge - File Processing Tools">
  <meta property="og:description" content="Merge, compress and convert files instantly with our privacy-focused browser tools">
  <meta property="og:type" content="website">
  
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/docx@7.8.2/build/index.min.js"></script>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script>
    // Set worker src for PDF.js
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
  </script>

  <script src="https://cdn.jsdelivr.net/npm/@imgly/background-removal@1.4.5/dist/index.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.2/dist/browser-image-compression.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qr-code-styling@1.6.0/lib/qr-code-styling.js"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(to right, #0f0f10, #111215);
      color: #f0f0f0;
      line-height: 1.6;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    a {
      text-decoration: none;
      color: inherit;
    }

    /* Header */
    header {
      background: rgba(15, 15, 16, 0.95);
      position: sticky;
      top: 0;
      z-index: 1000;
      backdrop-filter: blur(10px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }

    .nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      max-width: 1200px;
      margin: auto;
      padding: 1rem 2rem;
    }

    .nav h1 {
      font-size: 1.5rem;
      font-weight: 700;
      background: linear-gradient(90deg, #00f6ff, #6c5dd3);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .nav .nav-links {
      display: flex;
      gap: 1.5rem;
    }

    .nav .nav-links a {
      font-size: 1rem;
      color: #ccc;
      transition: color 0.2s;
    }

    .nav .nav-links a:hover {
      color: #fff;
    }

    /* Mobile menu styles */
    .mobile-menu-btn {
      display: none;
      background: none;
      border: none;
      color: #ccc;
      font-size: 1.5rem;
      cursor: pointer;
    }

    .mobile-menu {
      display: none;
      position: fixed;
      top: 70px;
      left: 0;
      right: 0;
      background: rgba(15, 15, 16, 0.98);
      padding: 1rem;
      z-index: 999;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    .mobile-menu.active {
      display: block;
    }

    .mobile-menu a {
      display: block;
      padding: 0.8rem 1rem;
      color: #ccc;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    .mobile-menu a:hover {
      color: #fff;
      background: rgba(108, 93, 211, 0.1);
    }

    .container {
      max-width: 1200px;
      margin: auto;
      padding: 2rem;
      flex: 1;
    }

    .hero {
      text-align: center;
      padding: 5rem 2rem 3rem;
    }

    .hero h2 {
      font-size: 2.8rem;
      background: linear-gradient(90deg, #00f6ff, #6c5dd3);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .hero p {
      color: #aaa;
      margin-top: 1rem;
      font-size: 1.2rem;
    }

    .cta {
      margin-top: 2rem;
    }

    .cta button {
      background: #6c5dd3;
      color: white;
      padding: 0.8rem 1.6rem;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      cursor: pointer;
      transition: 0.3s ease;
    }

    .cta button:hover {
      background: #5842c3;
    }

    /* Tool Cards Grid */
    .tools {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 2rem;
      margin-top: 4rem;
    }

    .tool-card {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(14px);
      border-radius: 14px;
      padding: 2rem;
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 0 20px rgba(108, 93, 211, 0.08);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .tool-card:hover {
      transform: translateY(-6px);
      box-shadow: 0 0 28px rgba(108, 93, 211, 0.25);
    }

    .tool-card h3 {
      font-size: 1.3rem;
      color: #fff;
      margin-bottom: 0.5rem;
    }

    .tool-card p {
      color: #bbb;
      font-size: 0.95rem;
    }

    /* Tool Content */
    .tool-content {
      display: none;
      margin-top: 1.5rem;
    }

    .tool-card.active {
      padding-bottom: 2.5rem;
    }

    .tool-card.active .tool-content {
      display: block;
    }

    .file-input {
      width: 100%;
      margin-bottom: 1rem;
    }

    .file-input label {
      display: block;
      margin-bottom: 0.5rem;
      color: #ddd;
      font-size: 0.9rem;
    }

    .file-input input[type="file"] {
      width: 100%;
      padding: 0.5rem;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      color: #fff;
      display: none;
    }

    .drag-drop-area {
      width: 100%;
      padding: 2rem;
      border: 2px dashed rgba(255,255,255,0.3);
      border-radius: 8px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
      margin-bottom: 1rem;
    }

    .drag-drop-area:hover {
      border-color: #6c5dd3;
      background: rgba(108, 93, 211, 0.1);
    }

    .drag-drop-area.active {
      border-color: #6c5dd3;
      background: rgba(108, 93, 211, 0.2);
    }

    .drag-drop-area p {
      margin-bottom: 0.5rem;
    }

    .drag-drop-area .small {
      font-size: 0.8rem;
      color: #aaa;
    }

    .file-list {
      margin-top: 1rem;
      max-height: 150px;
      overflow-y: auto;
    }

    .file-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem;
      background: rgba(255,255,255,0.05);
      border-radius: 4px;
      margin-bottom: 0.3rem;
    }

    .file-item-name {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 70%;
    }

    .file-item-size {
      font-size: 0.8rem;
      color: #aaa;
    }

    .file-item-remove {
      color: #ff6b6b;
      cursor: pointer;
      margin-left: 0.5rem;
    }

    .tool-btn {
      background: #6c5dd3;
      color: white;
      padding: 0.6rem 1.2rem;
      border: none;
      border-radius: 6px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: 0.3s ease;
      margin-top: 0.5rem;
      width: 100%;
    }

    .tool-btn:hover {
      background: #5842c3;
    }

    .tool-btn.secondary {
      background: transparent;
      border: 1px solid #6c5dd3;
      margin-top: 0.5rem;
    }

    .tool-btn:disabled {
      background: #555;
      cursor: not-allowed;
      opacity: 0.7;
    }

    .options {
      margin: 1rem 0;
    }

    .option-group {
      margin-bottom: 1rem;
    }

    .option-group label {
      display: block;
      margin-bottom: 0.3rem;
      color: #ddd;
      font-size: 0.9rem;
    }

    .option-group input[type="text"],
    .option-group input[type="number"],
    .option-group select,
    .option-group textarea {
      width: 100%;
      padding: 0.5rem;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      color: #fff;
    }

    .option-group input[type="range"] {
      width: 100%;
    }

    .option-group input[type="color"] {
      width: 100%;
      height: 40px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }

    .preview-container {
      margin-top: 1rem;
      text-align: center;
    }

    .preview-container img {
      max-width: 100%;
      max-height: 200px;
      border-radius: 6px;
    }

    .qr-code-container {
      display: flex;
      justify-content: center;
      margin: 1rem 0;
    }

    .qr-preview {
      margin: 1rem 0;
      text-align: center;
    }

    .qr-preview canvas {
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    /* Signature Canvas */
    .signature-container {
      margin: 1rem 0;
      text-align: center;
    }

    .signature-canvas {
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      background: rgba(255,255,255,0.05);
      cursor: crosshair;
      margin: 0 auto;
      display: block;
    }

    .signature-options {
      margin-top: 1rem;
    }

    .signature-btn {
      background: #6c5dd3;
      color: white;
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 6px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: 0.3s ease;
      margin-right: 0.5rem;
    }

    .signature-btn:hover {
      background: #5842c3;
    }

    .signature-btn.clear {
      background: #ff6b6b;
    }

    .signature-btn.clear:hover {
      background: #e74c3c;
    }

    /* Status messages */
    .status-message {
      margin-top: 1rem;
      padding: 0.5rem;
      border-radius: 4px;
      font-size: 0.9rem;
      text-align: center;
    }

    .status-message.success {
      background: rgba(46, 204, 113, 0.2);
      color: #2ecc71;
    }

    .status-message.error {
      background: rgba(231, 76, 60, 0.2);
      color: #e74c3c;
    }

    .status-message.processing {
      background: rgba(52, 152, 219, 0.2);
      color: #3498db;
    }

    /* About, Contact, Privacy pages styles */
    .content-page {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .content-container {
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem;
      flex: 1;
    }

    .content-page h1 {
      font-size: 2.5rem;
      margin-bottom: 1.5rem;
      background: linear-gradient(90deg, #00f6ff, #6c5dd3);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-align: center;
      padding-bottom: 0.5rem;
    }

    .content-page h2 {
      font-size: 1.8rem;
      margin: 2rem 0 1rem;
      color: #fff;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      padding-bottom: 0.5rem;
    }

    .content-page h3 {
      font-size: 1.3rem;
      margin: 1.5rem 0 1rem;
      color: #ddd;
    }

    .content-page p {
      margin-bottom: 1.2rem;
      color: #bbb;
      line-height: 1.7;
      font-size: 1.05rem;
    }

    .content-page ul, .content-page ol {
      margin-bottom: 1.5rem;
      padding-left: 2rem;
    }

    .content-page li {
      margin-bottom: 0.7rem;
      color: #bbb;
      line-height: 1.6;
    }

    .feature-list, .contact-box, .policy-section {
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(14px);
      border-radius: 14px;
      padding: 1.8rem;
      margin: 2rem 0;
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 0 20px rgba(108, 93, 211, 0.08);
    }

    .feature-item {
      margin-bottom: 1rem;
      padding-left: 1rem;
      border-left: 3px solid #6c5dd3;
    }

    .contact-method {
      margin-bottom: 1.5rem;
      padding: 1rem;
      background: rgba(108, 93, 211, 0.1);
      border-radius: 8px;
    }

    .contact-method h3 {
      color: #6c5dd3;
      margin-bottom: 0.5rem;
    }

    .content-page a {
      color: #6c5dd3;
      transition: color 0.2s;
      text-decoration: underline;
    }

    .content-page a:hover {
      color: #00f6ff;
    }

    .update-date {
      font-style: italic;
      color: #aaa;
      margin-bottom: 1.5rem;
      display: block;
      text-align: center;
      font-size: 0.95rem;
    }

    .privacy-notice {
      text-align: center;
      margin: 3rem 0;
      padding: 2rem;
      background: rgba(108, 93, 211, 0.1);
      border-radius: 14px;
      border: 1px solid rgba(108, 93, 211, 0.2);
    }

    .privacy-notice h2 {
      font-size: 2rem;
      background: linear-gradient(90deg, #00f6ff, #6c5dd3);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      border: none;
      margin-bottom: 1rem;
    }

    .privacy-notice p {
      font-size: 1.1rem;
      max-width: 700px;
      margin: 0 auto;
    }

    /* Footer */
    footer {
      margin-top: auto;
      padding: 2rem;
      text-align: center;
      font-size: 0.9rem;
      color: #666;
      border-top: 1px solid #222;
    }

    /* Fade In Animation */
    .fade-in {
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.8s ease;
    }

    .fade-in.visible {
      opacity: 1;
      transform: translateY(0);
    }

    /* Loading spinner */
    .spinner {
      display: none;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 1s ease-in-out infinite;
      margin: 0 auto;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Hide content sections by default */
    .content-section {
      display: none;
    }

    .active-section {
      display: block;
    }

    /* Accessibility improvements */
    button:focus, input:focus, select:focus, textarea:focus {
      outline: 2px solid #6c5dd3;
      outline-offset: 2px;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .hero h2 {
        font-size: 2rem;
        line-height: 1.2;
      }

      .hero {
        padding: 3rem 1rem 2rem;
      }

      .content-page h1 {
        font-size: 1.8rem;
      }

      .content-page h2 {
        font-size: 1.5rem;
      }

      .nav .nav-links {
        display: none;
      }

      .mobile-menu-btn {
        display: block;
      }

      .content-container, .container {
        padding: 1rem;
      }
      
      .tools {
        grid-template-columns: 1fr;
        gap: 1.5rem;
      }

      .tool-card {
        padding: 1.5rem;
      }

      .drag-drop-area {
        padding: 1.5rem;
      }

      .option-group {
        margin-bottom: 0.8rem;
      }

      .option-group label {
        font-size: 0.85rem;
      }

      .option-group input[type="text"],
      .option-group input[type="number"],
      .option-group select,
      .option-group textarea {
        padding: 0.4rem;
        font-size: 0.9rem;
      }

      .tool-btn {
        padding: 0.5rem 1rem;
        font-size: 0.85rem;
      }
    }

    @media (max-width: 480px) {
      .hero h2 {
        font-size: 1.7rem;
      }

      .hero p {
        font-size: 1rem;
      }

      .nav {
        padding: 0.8rem 1.1rem;
      }

      .nav h1 {
        font-size: 1.3rem;
      }

      .mobile-menu-btn {
        font-size: 1.3rem;
      }

      .mobile-menu {
        top: 60px;
      }

      .tool-card h3 {
        font-size: 1.2rem;
      }

      .tool-card p {
        font-size: 0.9rem;
      }

      .drag-drop-area {
        padding: 1rem;
      }

      .drag-drop-area p {
        font-size: 0.9rem;
      }

      .drag-drop-area .small {
        font-size: 0.75rem;
      }
    }

    @media (min-width: 769px) {
      .mobile-menu {
        display: none !important;
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="nav">
      <h1>Quick Merge</h1>
      <div class="nav-links">
        <a href="#" onclick="showSection('home')">Home</a>
        <a href="#" onclick="showSection('about')">About</a>
        <a href="#" onclick="showSection('contact')">Contact</a>
        <a href="#" onclick="showSection('privacy')">Privacy</a>
      </div>
      <button class="mobile-menu-btn" onclick="toggleMobileMenu()">
        <i class="fas fa-bars"></i>
      </button>
    </div>
    <div class="mobile-menu" id="mobileMenu">
      <a href="#" onclick="showSection('home'); toggleMobileMenu()">Home</a>
      <a href="#" onclick="showSection('about'); toggleMobileMenu()">About</a>
      <a href="#" onclick="showSection('contact'); toggleMobileMenu()">Contact</a>
      <a href="#" onclick="showSection('privacy'); toggleMobileMenu()">Privacy</a>
    </div>
  </header>

  <section id="home" class="content-section active-section">
    <section class="hero">
      <div class="container">
        <h2>Merge, Compress & Convert Files Instantly</h2>
        <p>All tools run locally in your browser â€” fast, private, and secure.</p>
        <div class="cta">
          <button onclick="document.getElementById('tools').scrollIntoView({ behavior: 'smooth' })">Explore Tools</button>
        </div>
      </div>
    </section>

    <section id="tools" class="container">
      <div class="tools">
        <div class="tool-card fade-in" id="merge-pdf-card">
          <h3>Merge PDF</h3>
          <p>Combine multiple PDF files into one seamless document.</p>
          <button class="tool-btn" onclick="toggleTool('merge-pdf')">Use Tool</button>
          <div class="tool-content" id="merge-pdf">
            <div class="file-input">
              <label for="merge-pdf-files">Select PDF files to merge:</label>
              <div class="drag-drop-area" id="merge-pdf-drop-area" tabindex="0" role="button" aria-label="Drag and drop area for PDF files">
                <p>Drag & drop PDF files here</p>
                <p class="small">or click to browse</p>
              </div>
              <input type="file" id="merge-pdf-files" accept=".pdf" multiple>
              <div class="file-list" id="merge-pdf-file-list"></div>
            </div>
            <button class="tool-btn" id="merge-pdf-btn" onclick="mergePDFs()" disabled>Merge PDFs</button>
            <div class="spinner" id="merge-pdf-spinner"></div>
            <div class="status-message" id="merge-pdf-status"></div>
          </div>
        </div>

        <div class="tool-card fade-in" id="split-pdf-card">
          <h3>Split PDF</h3>
          <p>Extract selected pages or split PDF into multiple parts.</p>
          <button class="tool-btn" onclick="toggleTool('split-pdf')">Use Tool</button>
          <div class="tool-content" id="split-pdf">
            <div class="file-input">
              <label for="split-pdf-file">Select PDF file to split:</label>
              <div class="drag-drop-area" id="split-pdf-drop-area" tabindex="0" role="button" aria-label="Drag and drop area for PDF files">
                <p>Drag & drop a PDF file here</p>
                <p class="small">or click to browse</p>
              </div>
              <input type="file" id="split-pdf-file" accept=".pdf">
              <div class="file-list" id="split-pdf-file-list"></div>
            </div>
            <div class="options">
              <div class="option-group">
                <label for="split-pages">Pages to extract (e.g., 1-3,5,7-9):</label>
                <input type="text" id="split-pages" placeholder="1-3,5,7-9">
              </div>
            </div>
            <button class="tool-btn" id="split-pdf-btn" onclick="splitPDF()" disabled>Split PDF</button>
            <div class="spinner" id="split-pdf-spinner"></div>
            <div class="status-message" id="split-pdf-status"></div>
          </div>
        </div>

        <div class="tool-card fade-in" id="compress-pdf-card">
          <h3>Compress PDF</h3>
          <p>Reduce PDF file size without losing quality or formatting.</p>
          <button class="tool-btn" onclick="toggleTool('compress-pdf')">Use Tool</button>
          <div class="tool-content" id="compress-pdf">
            <div class="file-input">
              <label for="compress-pdf-file">Select PDF file to compress:</label>
              <div class="drag-drop-area" id="compress-pdf-drop-area" tabindex="0" role="button" aria-label="Drag and drop area for PDF files">
                <p>Drag & drop a PDF file here</p>
                <p class="small">or click to browse</p>
              </div>
              <input type="file" id="compress-pdf-file" accept=".pdf">
              <div class="file-list" id="compress-pdf-file-list"></div>
            </div>
            <div class="options">
              <div class="option-group">
                <label for="compression-level">Compression level:</label>
                <select id="compression-level">
                  <option value="low">Low (better quality)</option>
                  <option value="medium" selected>Medium (balanced)</option>
                  <option value="high">High (smaller file)</option>
                  <option value="extreme">Extreme (maximum compression)</option>
                </select>
              </div>
              <div class="option-group">
                <label for="compression-mode">Compression Mode:</label>
                <select id="compression-mode">
                  <option value="balanced">Balanced (recommended)</option>
                  <option value="preserve-text">Preserve Text Quality</option>
                  <option value="preserve-images">Preserve Image Quality</option>
                </select>
              </div>
            </div>
            <button class="tool-btn" id="compress-pdf-btn" onclick="compressPDF()" disabled>Compress PDF</button>
            <div class="spinner" id="compress-pdf-spinner"></div>
            <div class="status-message" id="compress-pdf-status"></div>
          </div>
        </div>

        <div class="tool-card fade-in" id="image-to-pdf-card">
          <h3>Image to PDF</h3>
          <p>Convert one or multiple images to a single PDF document.</p>
          <button class="tool-btn" onclick="toggleTool('image-to-pdf')">Use Tool</button>
          <div class="tool-content" id="image-to-pdf">
            <div class="file-input">
              <label for="image-to-pdf-files">Select image(s) to convert:</label>
              <div class="drag-drop-area" id="image-to-pdf-drop-area" tabindex="0" role="button" aria-label="Drag and drop area for image files">
                <p>Drag & drop images here</p>
                <p class="small">or click to browse</p>
              </div>
              <input type="file" id="image-to-pdf-files" accept="image/*" multiple>
              <div class="file-list" id="image-to-pdf-file-list"></div>
            </div>
            <div class="options">
              <div class="option-group">
                <label for="pdf-layout">Page Layout:</label>
                <select id="pdf-layout">
                  <option value="portrait">Portrait</option>
                  <option value="landscape">Landscape</option>
                  <option value="auto">Auto (match image orientation)</option>
                </select>
              </div>
              <div class="option-group">
                <label for="pdf-margin">Margin (mm):</label>
                <input type="number" id="pdf-margin" min="0" max="50" value="5">
              </div>
            </div>
            <button class="tool-btn" id="image-to-pdf-btn" onclick="convertImagesToPDF()" disabled>Convert to PDF</button>
            <div class="spinner" id="image-to-pdf-spinner"></div>
            <div class="status-message" id="image-to-pdf-status"></div>
          </div>
        </div>

        <div class="tool-card fade-in" id="text-converter-card">
          <h3>Text to PDF</h3>
          <p>Convert plain text to professional PDF documents.</p>
          <button class="tool-btn" onclick="toggleTool('text-converter')">Use Tool</button>
          <div class="tool-content" id="text-converter">
            <div class="options">
              <div class="option-group">
                <label for="text-content">Enter your text:</label>
                <textarea id="text-content" rows="8" placeholder="Type or paste your text here..."></textarea>
              </div>
              <div class="option-group">
                <label for="text-filename">File name (without extension):</label>
                <input type="text" id="text-filename" placeholder="document">
              </div>
            </div>
            <button class="tool-btn" id="text-convert-btn" onclick="convertTextToPDF()">Convert to PDF</button>
            <div class="spinner" id="text-converter-spinner"></div>
            <div class="status-message" id="text-converter-status"></div>
          </div>
        </div>

        <div class="tool-card fade-in" id="pdf-to-word-card">
          <h3>PDF to Word</h3>
          <p>Convert PDF documents to editable Word files.</p>
          <button class="tool-btn" onclick="toggleTool('pdf-to-word')">Use Tool</button>
          <div class="tool-content" id="pdf-to-word">
            <div class="file-input">
              <label for="pdf-to-word-file">Select PDF file to convert:</label>
              <div class="drag-drop-area" id="pdf-to-word-drop-area" tabindex="0" role="button" aria-label="Drag and drop area for PDF files">
                <p>Drag & drop a PDF file here</p>
                <p class="small">or click to browse</p>
              </div>
              <input type="file" id="pdf-to-word-file" accept=".pdf">
              <div class="file-list" id="pdf-to-word-file-list"></div>
            </div>
            <div class="options">
              <div class="option-group">
                <label for="word-format">Output Format:</label>
                <select id="word-format">
                  <option value="docx">Word Document (.docx)</option>
                  <option value="rtf">Rich Text Format (.rtf)</option>
                </select>
              </div>
            </div>
            <button class="tool-btn" id="pdf-to-word-btn" onclick="convertPDFToWord()" disabled>Convert to Word</button>
            <div class="spinner" id="pdf-to-word-spinner"></div>
            <div class="status-message" id="pdf-to-word-status"></div>
          </div>
        </div>

        <div class="tool-card fade-in" id="pdf-signer-card">
          <h3>Sign PDF</h3>
          <p>Add your signature to PDF documents.</p>
          <button class="tool-btn" onclick="toggleTool('pdf-signer')">Use Tool</button>
          <div class="tool-content" id="pdf-signer">
            <div class="file-input">
              <label for="pdf-signer-file">Select PDF file to sign:</label>
              <div class="drag-drop-area" id="pdf-signer-drop-area" tabindex="0" role="button" aria-label="Drag and drop area for PDF files">
                <p>Drag & drop a PDF file here</p>
                <p class="small">or click to browse</p>
              </div>
              <input type="file" id="pdf-signer-file" accept=".pdf">
              <div class="file-list" id="pdf-signer-file-list"></div>
            </div>
            <div class="options">
              <div class="option-group">
                <label for="signature-page">Page Number to Sign:</label>
                <input type="number" id="signature-page" min="1" value="1">
              </div>
              <div class="option-group">
                <label for="signature-position">Signature Position:</label>
                <select id="signature-position">
                  <option value="bottom-right">Bottom Right</option>
                  <option value="bottom-left">Bottom Left</option>
                  <option value="top-right">Top Right</option>
                  <option value="top-left">Top Left</option>
                  <option value="center">Center</option>
                </select>
              </div>
              <div class="option-group">
                <label for="signature-size">Signature Size:</label>
                <select id="signature-size">
                  <option value="small">Small</option>
                  <option value="medium" selected>Medium</option>
                  <option value="large">Large</option>
                  <option value="custom">Custom</option>
                </select>
              </div>
              <div class="option-group" id="custom-size-group" style="display:none;">
                <label for="custom-width">Custom Width (px):</label>
                <input type="number" id="custom-width" min="50" max="500" value="150">
              </div>
            </div>
            <div class="signature-container">
              <label>Draw your signature:</label>
              <canvas id="signature-canvas" width="400" height="200" class="signature-canvas"></canvas>
              <div class="signature-options">
                <button class="signature-btn clear" onclick="clearSignature()">Clear</button>
                <button class="signature-btn" onclick="saveSignature()">Save Signature</button>
              </div>
            </div>
            <button class="tool-btn" id="sign-pdf-btn" onclick="signPDF()" disabled>Sign PDF</button>
            <div class="spinner" id="pdf-signer-spinner"></div>
            <div class="status-message" id="pdf-signer-status"></div>
          </div>
        </div>

        <div class="tool-card fade-in" id="compress-image-card">
          <h3>Compress Images</h3>
          <p>Smartly compress JPEG, PNG, or WebP images with advanced algorithms.</p>
          <button class="tool-btn" onclick="toggleTool('compress-image')">Use Tool</button>
          <div class="tool-content" id="compress-image">
            <div class="file-input">
              <label for="compress-image-files">Select image(s) to compress:</label>
              <div class="drag-drop-area" id="compress-image-drop-area" tabindex="0" role="button" aria-label="Drag and drop area for image files">
                <p>Drag & drop images here</p>
                <p class="small">or click to browse</p>
              </div>
              <input type="file" id="compress-image-files" accept="image/*" multiple>
              <div class="file-list" id="compress-image-file-list"></div>
            </div>
            <div class="options">
              <div class="option-group">
                <label for="image-quality">Quality (0-100):</label>
                <input type="range" id="image-quality" min="0" max="100" value="80">
                <span id="quality-value">80%</span>
              </div>
              <div class="option-group">
                <label for="image-resize">Resize to max width (px):</label>
                <input type="number" id="image-resize" min="100" max="5000" placeholder="Leave empty for no resizing">
              </div>
              <div class="option-group">
                <label for="output-format">Output format:</label>
                <select id="output-format">
                  <option value="original">Keep original format</option>
                  <option value="jpeg">JPEG</option>
                  <option value="png">PNG</option>
                  <option value="webp">WebP (best compression)</option>
                </select>
              </div>
              <div class="option-group">
                <label for="advanced-compression">Advanced Compression:</label>
                <select id="advanced-compression">
                  <option value="balanced">Balanced (recommended)</option>
                  <option value="aggressive">Aggressive (smaller files)</option>
                  <option value="conservative">Conservative (better quality)</option>
                </select>
              </div>
            </div>
            <button class="tool-btn" id="compress-image-btn" onclick="compressImages()" disabled>Compress Images</button>
            <div class="preview-container" id="image-preview"></div>
            <div class="spinner" id="compress-image-spinner"></div>
            <div class="status-message" id="compress-image-status"></div>
          </div>
        </div>

        <div class="tool-card fade-in" id="qr-code-card">
          <h3>Advanced QR Code Generator</h3>
          <p>Create stylish QR codes with logos, custom colors, and patterns.</p>
          <button class="tool-btn" onclick="toggleTool('qr-code')">Use Tool</button>
          <div class="tool-content" id="qr-code">
            <div class="options">
              <div class="option-group">
                <label for="qr-content">QR Code Content:</label>
                <input type="text" id="qr-content" placeholder="https://example.com">
              </div>
              <div class="option-group">
                <label for="qr-size">Size (px):</label>
                <input type="number" id="qr-size" min="100" max="1000" value="300">
              </div>
              <div class="option-group">
                <label for="qr-color">Foreground Color:</label>
                <input type="color" id="qr-color" value="#000000">
              </div>
              <div class="option-group">
                <label for="qr-bg-color">Background Color:</label>
                <input type="color" id="qr-bg-color" value="#ffffff">
              </div>
              <div class="option-group">
                <label for="qr-dot-type">Dot Style:</label>
                <select id="qr-dot-type">
                  <option value="square">Square</option>
                  <option value="dots">Dots</option>
                  <option value="rounded">Rounded</option>
                  <option value="extra-rounded">Extra Rounded</option>
                  <option value="classy">Classy</option>
                  <option value="classy-rounded">Classy Rounded</option>
                </select>
              </div>
              <div class="option-group">
                <label for="qr-corner-type">Corner Style:</label>
                <select id="qr-corner-type">
                  <option value="square">Square</option>
                  <option value="extra-rounded">Extra Rounded</option>
                  <option value="dot">Dot</option>
                </select>
              </div>
            </div>
            <button class="tool-btn" id="generate-qr-btn" onclick="generateQRCode()">Generate QR Code</button>
            <div class="qr-preview" id="qr-preview"></div>
            <button class="tool-btn secondary" id="download-qr-btn" style="display:none;" onclick="downloadQRCode()">Download QR Code</button>
            <div class="status-message" id="qr-code-status"></div>
          </div>
        </div>
      </div>
    </section>
  </section>

  <section id="about" class="content-section content-page">
    <div class="content-container">
      <h1 class="fade-in">About Quick Merge</h1>
      
      <p class="fade-in">Quick Merge is a revolutionary client-side file processing tool that empowers you to merge, split, convert, and edit files directly in your browserâ€”without ever compromising your privacy by uploading them to external servers.</p>
      
      <div class="feature-list fade-in">
        <h2>Why Choose Quick Merge?</h2>
        <div class="feature-item">
          <strong>Complete Privacy Assurance</strong> - Your files never leave your device, ensuring maximum security for sensitive documents
        </div>
        <div class="feature-item">
          <strong>No Account Required</strong> - Get started immediately without registration or login
        </div>
        <div class="feature-item">
          <strong>Professional-Grade Tools</strong> - Powerful features designed for both casual users and professionals
        </div>
        <div class="feature-item">
          <strong>Universal Compatibility</strong> - Works seamlessly across all modern browsers and devices
        </div>
      </div>
      
      <h2 class="fade-in">Our Technology</h2>
      <p class="fade-in">Quick Merge leverages cutting-edge web technologies to bring you:</p>
      <ul class="fade-in">
        <li>Advanced PDF manipulation using PDF-lib technology</li>
        <li>Efficient image processing with WebAssembly</li>
        <li>Client-side file handling with Web APIs</li>
        <li>Secure processing environment isolated from external networks</li>
      </ul>
      
      <h2 class="fade-in">Who Uses Quick Merge?</h2>
      <p class="fade-in">Our tools are trusted by professionals across industries:</p>
      <ul class="fade-in">
        <li>Legal professionals handling sensitive case documents</li>
        <li>Healthcare providers managing patient records</li>
        <li>Financial analysts working with confidential reports</li>
        <li>Students and educators organizing research materials</li>
        <li>Business professionals preparing presentations and contracts</li>
      </ul>
    </div>
  </section>

  <section id="contact" class="content-section content-page">
    <div class="content-container">
      <h1 class="fade-in">Contact Quick Merge</h1>
      
      <div class="contact-box fade-in">
        <h2>Get in Touch</h2>
        <p>We're committed to providing exceptional support and value your feedback. Here's how you can reach us:</p>
        
        <div class="contact-method">
          <h3>Technical Support</h3>
          <p>Email: <a href="mailto:danielledawoodk@gmail.com">danielledawoodk@gmail.com</a></p>
          <p>For assistance with tool functionality, troubleshooting, or feature requests.</p>
        </div>
        
        <div class="contact-method">
          <h3>Privacy Questions</h3>
          <p>Email: <a href="mailto:danielledawoodk@gmail.com">danielledawoodk@gmail.com</a></p>
          <p>For any concerns regarding our privacy policy or data handling practices.</p>
        </div>
      </div>
      
      <h2 class="fade-in">Support Hours</h2>
      <p class="fade-in">Our team is available to assist you during the following hours:</p>
      <ul class="fade-in">
        <li>Monday-Friday: 9:00 AM - 5:00 PM (GMT)</li>
        <li>Emergency support available for critical issues</li>
        <li>Typical response time: 24-48 hours</li>
      </ul>
      
      <h2 class="fade-in">We Value Your Feedback</h2>
      <p class="fade-in">Help us improve Quick Merge by sharing your thoughts on:</p>
      <ul class="fade-in">
        <li>New features you'd like to see implemented</li>
        <li>Your experience with our current tools</li>
        <li>Any difficulties you've encountered</li>
        <li>Suggestions for improving our interface</li>
      </ul>
      
      <h2 class="fade-in">Business Partnerships</h2>
      <p class="fade-in">Interested in integrating Quick Merge technology into your platform?</p>
      <p class="fade-in">Contact our business development team at <a href="mailto:danielledawoodk@gmail.com">danielledawoodk@gmail.com</a> to discuss collaboration opportunities.</p>
    </div>
  </section>

  <section id="privacy" class="content-section content-page">
    <div class="content-container">
      <h1 class="fade-in">Privacy Policy</h1>
      <p class="update-date fade-in">Last Updated: 21.05.2025</p>
      
      <div class="policy-section fade-in">
        <h2>Our Commitment to Privacy</h2>
        <p>At Quick Merge, we've built our platform on a fundamental principle: your data belongs to you. Unlike traditional online tools, we've designed our service to operate entirely within your browser, ensuring complete privacy and security.</p>
      </div>
      
      <div class="policy-section fade-in">
        <h2>How We Protect Your Data</h2>
        
        <h3>Local Processing Architecture</h3>
        <p>Our innovative approach means:</p>
        <ul>
          <li><strong>Zero Data Transmission:</strong> Files are processed directly in your browser with no server interaction</li>
          <li><strong>Automatic Cleanup:</strong> All temporary data is purged when you close your browser tab</li>
          <li><strong>No Tracking:</strong> We don't use cookies, analytics, or any tracking mechanisms</li>
        </ul>
        
        <h3>Security Features</h3>
        <p>We've implemented multiple safeguards:</p>
        <ul>
          <li>Modern encryption standards for all processing</li>
          <li>Sandboxed execution environment</li>
          <li>Regular security audits of our codebase</li>
        </ul>
      </div>
      
      <div class="policy-section fade-in">
        <h2>Your Responsibilities</h2>
        <p>While we provide the tools for secure processing, we recommend:</p>
        <ul>
          <li>Using updated browsers with security patches</li>
          <li>Avoiding public computers for sensitive documents</li>
          <li>Maintaining your device's antivirus protection</li>
        </ul>
      </div>
      
      <div class="policy-section fade-in">
        <h2>Policy Updates</h2>
        <p>We may occasionally update this policy to reflect:</p>
        <ul>
          <li>New features that maintain our privacy standards</li>
          <li>Changes in applicable laws and regulations</li>
          <li>Improvements to our security documentation</li>
        </ul>
        <p>We encourage you to review this policy periodically to stay informed about how we're protecting your information.</p>
      </div>
      
      <div class="policy-section fade-in">
        <h2>Contact Us</h2>
        <p>For any questions about this Privacy Policy or our practices, please contact our Privacy Officer at <a href="mailto:danielledawoodk@gmail.com">danielledawoodk@gmail.com</a>.</p>
      </div>
    </div>
  </section>

  <footer>
    Â© 2025 Quick Merge â€“ All rights reserved.
  </footer>

  <script>
    // Navigation function
    function showSection(sectionId) {
      // Hide all sections
      document.querySelectorAll('.content-section').forEach(section => {
        section.classList.remove('active-section');
      });
      
      // Show the selected section
      document.getElementById(sectionId).classList.add('active-section');
      
      // Scroll to top
      window.scrollTo(0, 0);
      
      // Trigger animations for the new section
      if (sectionId !== 'home') {
        setTimeout(() => {
          setupAnimations();
        }, 50);
      }
    }

    // Toggle mobile menu
    function toggleMobileMenu() {
      const mobileMenu = document.getElementById('mobileMenu');
      mobileMenu.classList.toggle('active');
    }

    // Close mobile menu when clicking outside
    document.addEventListener('click', function(event) {
      const mobileMenu = document.getElementById('mobileMenu');
      const menuBtn = document.querySelector('.mobile-menu-btn');
      
      if (!mobileMenu.contains(event.target) && event.target !== menuBtn && !menuBtn.contains(event.target)) {
        mobileMenu.classList.remove('active');
      }
    });

    // Close mobile menu on resize for desktop view
    window.addEventListener('resize', function() {
      const mobileMenu = document.getElementById('mobileMenu');
      if (window.innerWidth >= 769) { // Adjust breakpoint as needed
        mobileMenu.classList.remove('active');
      }
    });

    let signatureImage = null; // Stored signature image dataURL

    function setupSignatureCanvas() {
      const signatureCanvas = document.getElementById('signature-canvas');
      const signatureCtx = signatureCanvas.getContext('2d');
      
      // Set canvas background
      signatureCtx.fillStyle = 'rgba(255, 255, 255, 0.05)';
      signatureCtx.fillRect(0, 0, signatureCanvas.width, signatureCanvas.height);
      signatureCtx.strokeStyle = '#6c5dd3';
      signatureCtx.lineWidth = 2;
      signatureCtx.lineCap = 'round';
      signatureCtx.lineJoin = 'round';

      let isDrawing = false;
      let lastX = 0;
      let lastY = 0;
      
      // Mouse event handlers
      signatureCanvas.addEventListener('mousedown', startDrawing);
      signatureCanvas.addEventListener('mousemove', draw);
      signatureCanvas.addEventListener('mouseup', stopDrawing);
      // Removed mouseout from stopDrawing to improve UX
      
      // Touch event handlers for mobile
      signatureCanvas.addEventListener('touchstart', handleTouchStart);
      signatureCanvas.addEventListener('touchmove', handleTouchMove);
      signatureCanvas.addEventListener('touchend', stopDrawing);

      function startDrawing(e) {
        isDrawing = true;
        const rect = signatureCanvas.getBoundingClientRect();
        lastX = e.clientX - rect.left;
        lastY = e.clientY - rect.top;
      }
      
      function draw(e) {
        if (!isDrawing) return;
        
        const rect = signatureCanvas.getBoundingClientRect();
        const currentX = e.clientX - rect.left;
        const currentY = e.clientY - rect.top;
        
        signatureCtx.beginPath();
        signatureCtx.moveTo(lastX, lastY);
        signatureCtx.lineTo(currentX, currentY);
        signatureCtx.stroke();
        
        lastX = currentX;
        lastY = currentY;
      }
      
      function stopDrawing() {
        isDrawing = false;
      }
      
      function handleTouchStart(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousedown', {
          clientX: touch.clientX,
          clientY: touch.clientY
        });
        startDrawing(mouseEvent);
      }
      
      function handleTouchMove(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousemove', {
          clientX: touch.clientX,
          clientY: touch.clientY
        });
        draw(mouseEvent);
      }

      window.clearSignature = function() { // Expose to global scope
        signatureCtx.clearRect(0, 0, signatureCanvas.width, signatureCanvas.height);
        signatureCtx.fillStyle = 'rgba(255, 255, 255, 0.05)';
        signatureCtx.fillRect(0, 0, signatureCanvas.width, signatureCanvas.height);
        signatureImage = null;
        document.getElementById('sign-pdf-btn').disabled = true; // Disable sign button if signature is cleared
      };
      
      window.saveSignature = function() { // Expose to global scope
        // Check if there's actually a signature drawn
        const blankCanvas = document.createElement('canvas');
        blankCanvas.width = signatureCanvas.width;
        blankCanvas.height = signatureCanvas.height;
        const blankCtx = blankCanvas.getContext('2d');
        blankCtx.fillStyle = 'rgba(255, 255, 255, 0.05)';
        blankCtx.fillRect(0, 0, blankCanvas.width, blankCanvas.height);
        
        const blankData = blankCtx.getImageData(0, 0, blankCanvas.width, blankCanvas.height).data;
        const signatureData = signatureCtx.getImageData(0, 0, signatureCanvas.width, signatureCanvas.height).data;
        
        let isBlank = true;
        for (let i = 0; i < signatureData.length; i++) {
          if (signatureData[i] !== blankData[i]) {
            isBlank = false;
            break;
          }
        }
        
        if (isBlank) {
          showStatus('pdf-signer', 'Please draw a signature first', 'error');
          return;
        }
        
        signatureImage = signatureCanvas.toDataURL('image/png');
        showStatus('pdf-signer', 'Signature saved!', 'success');
        document.getElementById('sign-pdf-btn').disabled = false;
      };

      // Signature size selector
      document.getElementById('signature-size').addEventListener('change', function() {
        if (this.value === 'custom') {
          document.getElementById('custom-size-group').style.display = 'block';
        } else {
          document.getElementById('custom-size-group').style.display = 'none';
        }
      });
    }

    document.addEventListener('DOMContentLoaded', function() {
      // Initialize all tool sections
      setupDragAndDrop('merge-pdf', true);
      setupDragAndDrop('split-pdf', false);
      setupDragAndDrop('compress-pdf', false);
      setupDragAndDrop('compress-image', true);
      setupDragAndDrop('image-to-pdf', true);
      setupDragAndDrop('pdf-to-word', false);
      setupDragAndDrop('pdf-signer', false);
      
      // Set up signature canvas
      setupSignatureCanvas();
      
      // Set up fade-in animations
      setupAnimations();
      
      // Setup quality slider
      const qualitySlider = document.getElementById('image-quality');
      const qualityValue = document.getElementById('quality-value');
      if (qualitySlider && qualityValue) {
        qualitySlider.addEventListener('input', function() {
          qualityValue.textContent = this.value + '%';
        });
      }
      
      // Setup QR code live preview
      const qrInputs = ['qr-content', 'qr-size', 'qr-color', 'qr-bg-color', 'qr-dot-type', 'qr-corner-type'];
      qrInputs.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
          element.addEventListener('input', debounce(generateQRCodePreview, 500));
          element.addEventListener('change', debounce(generateQRCodePreview, 500));
        }
      });
    });

    function setupDragAndDrop(toolId, allowMultiple) {
      const dropArea = document.getElementById(`${toolId}-drop-area`);
      const fileInput = document.getElementById(`${toolId}-${allowMultiple ? 'files' : 'file'}`);
      const fileList = document.getElementById(`${toolId}-file-list`);
      const actionBtn = document.getElementById(`${toolId}-btn`);

      if (!dropArea || !fileInput) {
        console.error(`Elements not found for tool: ${toolId}`);
        return;
      }

      // Prevent default drag behaviors
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropArea.addEventListener(eventName, preventDefaults, false);
        document.body.addEventListener(eventName, preventDefaults, false);
      });

      // Highlight drop area when item is dragged over it
      ['dragenter', 'dragover'].forEach(eventName => {
        dropArea.addEventListener(eventName, highlight, false);
      });

      ['dragleave', 'drop'].forEach(eventName => {
        dropArea.addEventListener(eventName, unhighlight, false);
      });

      // Handle dropped files
      dropArea.addEventListener('drop', function(e) {
        const dt = e.dataTransfer;
        const files = dt.files;

        if (!allowMultiple && files.length > 1) {
          showStatus(toolId, 'Please select only one file for this tool.', 'error');
          return;
        }
        // Update the file input with the dropped files
        fileInput.files = files;
        handleFiles(files, fileList, actionBtn, allowMultiple); // Pass allowMultiple for accurate button state
      }, false);
      
      // Handle click to browse files
      dropArea.addEventListener('click', function() {
        fileInput.value = null; // Reset to allow selecting same file again
        fileInput.multiple = allowMultiple;
        fileInput.click();
      });

      // Handle file selection via input
      fileInput.addEventListener('change', function(e) {
        handleFiles(e.target.files, fileList, actionBtn, allowMultiple); // Pass allowMultiple for accurate button state
      });

      function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
      }

      function highlight() {
        dropArea.classList.add('active');
      }

      function unhighlight() {
        dropArea.classList.remove('active');
      }
    }

    function handleFiles(files, fileListElement, actionBtn, allowMultiple) {
      if (!files || files.length === 0) {
        fileListElement.innerHTML = '';
        if (actionBtn) actionBtn.disabled = true;
        return;
      }

      // Clear previous files if single file allowed
      if (!allowMultiple) {
        fileListElement.innerHTML = '';
        if (files.length > 1) {
          showStatus(fileListElement.closest('.tool-content').id, 'Please select only one file for this tool.', 'error');
          if (actionBtn) actionBtn.disabled = true;
          return;
        }
      }
      
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        const fileItem = document.createElement('div');
        fileItem.className = 'file-item';
        
        const fileNameSpan = document.createElement('span');
        fileNameSpan.className = 'file-item-name';
        fileNameSpan.textContent = sanitizeFilename(file.name);
        
        const fileSizeSpan = document.createElement('span');
        fileSizeSpan.className = 'file-item-size';
        fileSizeSpan.textContent = formatFileSize(file.size);
        
        const removeSpan = document.createElement('span');
        removeSpan.className = 'file-item-remove';
        removeSpan.innerHTML = '&times;';
        removeSpan.addEventListener('click', function(e) {
          e.stopPropagation();
          fileItem.remove();
          // Re-evaluate button state after removal
          if (actionBtn) {
            actionBtn.disabled = (fileListElement.children.length === 0) || (!allowMultiple && fileListElement.children.length !== 1);
          }
        });
        
        fileItem.appendChild(fileNameSpan);
        fileItem.appendChild(fileSizeSpan);
        fileItem.appendChild(removeSpan);
        
        fileListElement.appendChild(fileItem);
      }
      
      // Enable the action button if files are selected appropriately
      if (actionBtn) {
        actionBtn.disabled = (fileListElement.children.length === 0) || (!allowMultiple && fileListElement.children.length !== 1);
      }
    }

    function sanitizeFilename(filename) {
      return filename.replace(/[^\w\.\-]/g, '_');
    }

    function formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    function toggleTool(toolId) {
      const toolCard = document.getElementById(`${toolId}-card`);
      const toolContent = document.getElementById(toolId);
      
      if (toolCard.classList.contains('active')) {
        toolCard.classList.remove('active');
        toolContent.style.display = 'none';
      } else {
        // Close all other tools first
        document.querySelectorAll('.tool-card.active').forEach(card => {
          card.classList.remove('active');
          card.querySelector('.tool-content').style.display = 'none';
        });
        
        toolCard.classList.add('active');
        toolContent.style.display = 'block';
      }
    }

    function setupAnimations() {
      const fadeElements = document.querySelectorAll('.fade-in');
      
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add('visible');
          }
        });
      }, { threshold: 0.1 });
      
      fadeElements.forEach(element => {
        observer.observe(element);
      });
    }

    function resetTool(toolId) {
      // Clear file inputs and lists
      const fileInput = document.getElementById(`${toolId}-${toolId.includes('merge') || toolId.includes('image-to-pdf') || toolId.includes('compress-image') ? 'files' : 'file'}`);
      const fileList = document.getElementById(`${toolId}-file-list`);
      
      if (fileInput) fileInput.value = '';
      if (fileList) fileList.innerHTML = '';
      
      // Disable action button
      const actionBtn = document.getElementById(`${toolId}-btn`);
      if (actionBtn) actionBtn.disabled = true;
      
      // Clear status messages
      const statusElement = document.getElementById(`${toolId}-status`);
      if (statusElement) {
        statusElement.textContent = '';
        statusElement.className = 'status-message';
      }
      
      // Hide spinner
      const spinner = document.getElementById(`${toolId}-spinner`);
      if (spinner) spinner.style.display = 'none';
      
      // For QR code tool, hide download button
      if (toolId === 'qr-code') {
        document.getElementById('download-qr-btn').style.display = 'none';
        document.getElementById('qr-preview').innerHTML = '';
        document.getElementById('qr-content').value = '';
        // showStatus('qr-code', '', ''); // Redundant with general status clear
      }
      
      // For text converter, clear textarea
      if (toolId === 'text-converter') {
        document.getElementById('text-content').value = '';
        document.getElementById('text-filename').value = ''; // Clear filename too
      }
      
      // For PDF signer, clear signature
      if (toolId === 'pdf-signer') {
        clearSignature(); // Calls the global clearSignature function
        document.getElementById('sign-pdf-btn').disabled = true; // Ensures button is disabled if signature is cleared
      }
    }

    // PDF Processing Functions
    async function mergePDFs() {
      const fileInput = document.getElementById('merge-pdf-files');
      if (!fileInput.files || fileInput.files.length < 2) {
        showStatus('merge-pdf', 'Please select at least 2 PDF files to merge', 'error');
        return;
      }

      showStatus('merge-pdf', 'Merging PDFs...', 'processing');
      showSpinner('merge-pdf');
      
      try {
        const { PDFDocument } = PDFLib;
        const mergedPdf = await PDFDocument.create();
        
        // Process each file
        for (let i = 0; i < fileInput.files.length; i++) {
          const file = fileInput.files[i];
          if (file.type !== 'application/pdf') { // Basic type check
            showStatus('merge-pdf', `Skipping non-PDF file: ${file.name}`, 'error');
            continue;
          }
          const fileBuffer = await file.arrayBuffer();
          const pdfDoc = await PDFDocument.load(fileBuffer);
          
          // Copy pages
          const pages = await mergedPdf.copyPages(pdfDoc, pdfDoc.getPageIndices());
          pages.forEach(page => mergedPdf.addPage(page));
        }

        if (mergedPdf.getPageCount() === 0) { // Check if any pages were actually added
          showStatus('merge-pdf', 'No valid PDF pages were merged. Please ensure your files are valid PDFs.', 'error');
          return;
        }
        
        // Save merged PDF
        const mergedPdfBytes = await mergedPdf.save();
        const blob = new Blob([mergedPdfBytes], { type: 'application/pdf' });
        
        // Download the file
        saveAs(blob, 'merged-document.pdf');
        showStatus('merge-pdf', 'PDFs merged successfully!', 'success');
        
        // Reset tool after download
        setTimeout(() => resetTool('merge-pdf'), 2000);
      } catch (error) {
        console.error('Error merging PDFs:', error);
        showStatus('merge-pdf', 'Error merging PDFs: ' + error.message, 'error');
      } finally {
        hideSpinner('merge-pdf');
      }
    }

    async function splitPDF() {
      const fileInput = document.getElementById('split-pdf-file');
      const pagesInput = document.getElementById('split-pages');
      
      if (!fileInput.files || fileInput.files.length === 0) {
        showStatus('split-pdf', 'Please select a PDF file to split', 'error');
        return;
      }
      
      if (!pagesInput.value.trim()) {
        showStatus('split-pdf', 'Please specify pages to extract', 'error');
        return;
      }

      showStatus('split-pdf', 'Splitting PDF...', 'processing');
      showSpinner('split-pdf');
      
      try {
        const { PDFDocument } = PDFLib;
        const file = fileInput.files[0];
        const fileBuffer = await file.arrayBuffer();
        const pdfDoc = await PDFDocument.load(fileBuffer);
        
        // Parse page ranges
        const pageRanges = parsePageRanges(pagesInput.value, pdfDoc.getPageCount());
        if (pageRanges.length === 0) {
          showStatus('split-pdf', 'Invalid page range specified or no pages found in range. Max pages: ' + pdfDoc.getPageCount(), 'error');
          hideSpinner('split-pdf'); // Ensure spinner hides on early exit
          return; // Fix: Add return here to stop execution
        }
        
        // Create new PDF with selected pages
        const newPdf = await PDFDocument.create();
        for (const pageNum of pageRanges) {
          // Ensure pageNum is within valid bounds after parsing
          if (pageNum > 0 && pageNum <= pdfDoc.getPageCount()) {
            const [copiedPage] = await newPdf.copyPages(pdfDoc, [pageNum - 1]);
            newPdf.addPage(copiedPage);
          } else {
            console.warn(`Skipping invalid page number: ${pageNum}`);
          }
        }

        if (newPdf.getPageCount() === 0) { // Check if any pages were actually copied
          showStatus('split-pdf', 'No pages extracted. Check your page range.', 'error');
          return;
        }
        
        // Save split PDF
        const splitPdfBytes = await newPdf.save();
        const blob = new Blob([splitPdfBytes], { type: 'application/pdf' });
        
        // Download the file
        saveAs(blob, 'split-document.pdf');
        showStatus('split-pdf', 'PDF split successfully!', 'success');
        
        // Reset tool after download
        setTimeout(() => resetTool('split-pdf'), 2000);
      } catch (error) {
        console.error('Error splitting PDF:', error);
        showStatus('split-pdf', 'Error splitting PDF: ' + error.message, 'error');
      } finally {
        hideSpinner('split-pdf');
      }
    }

    function parsePageRanges(rangeStr, maxPages) {
      const ranges = rangeStr.split(',');
      const pages = new Set();
      
      for (const range of ranges) {
        const trimmedRange = range.trim();
        if (trimmedRange.includes('-')) {
          const parts = trimmedRange.split('-').map(Number);
          let start = parts[0];
          let end = parts[1];

          // Handle cases like "5-" or "-10" by assuming boundaries
          if (isNaN(start) && isNaN(end)) continue; // Both invalid
          if (isNaN(start)) start = 1;
          if (isNaN(end)) end = maxPages;
          
          const validStart = Math.max(1, Math.min(start, maxPages));
          const validEnd = Math.max(1, Math.min(end, maxPages));
          
          for (let i = validStart; i <= validEnd; i++) {
            pages.add(i);
          }
        } else if (trimmedRange) {
          const page = Number(trimmedRange);
          if (page >= 1 && page <= maxPages) {
            pages.add(page);
          }
        }
      }
      
      return Array.from(pages).sort((a, b) => a - b);
    }

    async function compressPDF() {
      const fileInput = document.getElementById('compress-pdf-file');
      const compressionLevel = document.getElementById('compression-level').value;
      const compressionMode = document.getElementById('compression-mode').value;
      
      if (!fileInput.files || fileInput.files.length === 0) {
        showStatus('compress-pdf', 'Please select a PDF file to compress', 'error');
        return;
      }

      showStatus('compress-pdf', 'Compressing PDF...', 'processing');
      showSpinner('compress-pdf');
      
      try {
        const { PDFDocument } = PDFLib;
        const file = fileInput.files[0];
        const fileBuffer = await file.arrayBuffer();
        const pdfDoc = await PDFDocument.load(fileBuffer);
        
        // Enhanced compression options based on level and mode
        const options = {
          useObjectStreams: true,
          addDefaultPage: false,
          objectsPerTick: 50,
          updateFieldAppearances: false,
          // PDF-lib's save method doesn't directly offer compression levels like 'low', 'medium', 'high', 'extreme'
          // nor modes like 'preserve-text', 'preserve-images' in the way user might expect.
          // These options mainly influence internal PDF structure and object encoding.
          // For true content compression (e.g., image downsampling), a dedicated PDF optimization library is often needed.
          // We will map these to 'PDFDocument.save' options as best as possible.
        };
        
        // Adjust options based on compression level (simulated best effort with PDF-lib)
        // PDF-lib's compression is mostly about object stream encoding and filtering.
        // It doesn't perform lossy compression on embedded images like dedicated tools.
        if (compressionLevel === 'low') {
          options.useObjectStreams = false; // Less aggressive on object streams
        } else if (compressionLevel === 'high') {
          options.useObjectStreams = true;
          options.objectsPerTick = 100; // More objects processed at once
        } else if (compressionLevel === 'extreme') {
          options.useObjectStreams = true;
          options.objectsPerTick = 200;
          // Note: ignoreEncryption and throwOnInvalidObject are for loading, not saving compression
          // options.ignoreEncryption = true;
          // options.throwOnInvalidObject = false;
        }
        
        // Compression mode for text/images is more complex and typically requires parsing content streams.
        // PDF-lib v1.x does not provide direct methods for this during 'save'.
        // These settings will currently have no functional effect on 'save'.
        // If advanced compression is truly needed, consider a different library or server-side processing.
        /*
        if (compressionMode === 'preserve-text') {
          // No direct API in PDF-lib for this during save without content stream manipulation
        } else if (compressionMode === 'preserve-images') {
          // No direct API in PDF-lib for this during save without content stream manipulation
        }
        */
        
        // Save compressed PDF
        const compressedPdfBytes = await pdfDoc.save(options);
        const blob = new Blob([compressedPdfBytes], { type: 'application/pdf' });
        
        // Calculate compression ratio
        const originalSize = file.size;
        const compressedSize = blob.size;
        const ratio = ((originalSize - compressedSize) / originalSize * 100).toFixed(2);
        
        // Download the file
        saveAs(blob, 'compressed-document.pdf');
        showStatus('compress-pdf', `PDF compressed successfully! Size reduced by ${ratio}%`, 'success');
        
        // Reset tool after download
        setTimeout(() => resetTool('compress-pdf'), 2000);
      } catch (error) {
        console.error('Error compressing PDF:', error);
        showStatus('compress-pdf', 'Error compressing PDF: ' + error.message, 'error');
      } finally {
        hideSpinner('compress-pdf');
      }
    }

    async function convertImagesToPDF() {
      const fileInput = document.getElementById('image-to-pdf-files');
      const layout = document.getElementById('pdf-layout').value;
      const margin = parseInt(document.getElementById('pdf-margin').value);
      
      if (!fileInput.files || fileInput.files.length === 0) {
        showStatus('image-to-pdf', 'Please select at least one image to convert', 'error');
        return;
      }

      showStatus('image-to-pdf', 'Converting images to PDF...', 'processing');
      showSpinner('image-to-pdf');
      
      try {
        const { PDFDocument } = PDFLib;
        const pdfDoc = await PDFDocument.create();
        
        // Process each image
        for (let i = 0; i < fileInput.files.length; i++) {
          const file = fileInput.files[i];
          if (!file.type.match('image.*')) {
            console.warn(`Skipping non-image file: ${file.name}`);
            continue;
          }
          
          const imageBytes = await file.arrayBuffer();
          let image;
          let embeddedImageSuccess = false;

          try {
            if (file.type === 'image/jpeg' || file.type === 'image/jpg') {
              image = await pdfDoc.embedJpg(imageBytes);
              embeddedImageSuccess = true;
            } else if (file.type === 'image/png') {
              image = await pdfDoc.embedPng(imageBytes);
              embeddedImageSuccess = true;
            } else {
              // For other image types, convert to JPEG first
              showStatus('image-to-pdf', `Converting ${file.name} to JPEG for PDF embedding...`, 'processing');
              const convertedImageBlob = await convertImageToJpeg(file);
              if (convertedImageBlob) {
                image = await pdfDoc.embedJpg(await convertedImageBlob.arrayBuffer());
                embeddedImageSuccess = true;
              } else {
                showStatus('image-to-pdf', `Failed to convert ${file.name} to JPEG. Skipping.`, 'error');
              }
            }
            
            if (!embeddedImageSuccess) continue; // Skip if embedding failed

            // Determine page size based on layout and image dimensions
            let pageWidth, pageHeight;
            const marginPoints = margin * 2.83465; // Convert mm to points (1mm = 2.83465pt)
            
            // Calculate content area dimensions
            const contentWidth = image.width;
            const contentHeight = image.height;

            if (layout === 'auto') {
              pageWidth = contentWidth + (marginPoints * 2);
              pageHeight = contentHeight + (marginPoints * 2);
            } else if (layout === 'landscape') {
                // Ensure page is wider than it is tall
                if (contentWidth > contentHeight) {
                    pageWidth = contentWidth + (marginPoints * 2);
                    pageHeight = contentHeight + (marginPoints * 2);
                } else {
                    pageWidth = contentHeight + (marginPoints * 2); // Swap dimensions for landscape orientation
                    pageHeight = contentWidth + (marginPoints * 2);
                }
            } else { // portrait
                // Ensure page is taller than it is wide
                if (contentHeight > contentWidth) {
                    pageWidth = contentWidth + (marginPoints * 2);
                    pageHeight = contentHeight + (marginPoints * 2);
                } else {
                    pageWidth = contentHeight + (marginPoints * 2); // Swap dimensions for portrait orientation
                    pageHeight = contentWidth + (marginPoints * 2);
                }
            }
            
            // Add a new page with the calculated dimensions
            const page = pdfDoc.addPage([pageWidth, pageHeight]);
            
            // Draw the image centered on the page with margins
            const scale = Math.min(
              (pageWidth - marginPoints * 2) / image.width,
              (pageHeight - marginPoints * 2) / image.height
            );
            
            const scaledWidth = image.width * scale;
            const scaledHeight = image.height * scale;
            
            page.drawImage(image, {
              x: (pageWidth - scaledWidth) / 2,
              y: (pageHeight - scaledHeight) / 2,
              width: scaledWidth,
              height: scaledHeight,
            });
          } catch (error) {
            console.error(`Error processing image ${file.name}:`, error);
            showStatus('image-to-pdf', `Error processing ${file.name}: ${error.message}. Skipping.`, 'error');
            continue; // Skip to next file if an error occurs
          }
        }
        
        if (pdfDoc.getPageCount() === 0) {
          showStatus('image-to-pdf', 'No valid images were processed or added to PDF.', 'error');
          return;
        }
        
        // Save the PDF
        const pdfBytes = await pdfDoc.save();
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        
        // Download the file
        saveAs(blob, 'converted-images.pdf');
        showStatus('image-to-pdf', 'Images converted to PDF successfully!', 'success');
        
        // Reset tool after download
        setTimeout(() => resetTool('image-to-pdf'), 2000);
      } catch (error) {
        console.error('Error converting images to PDF:', error);
        showStatus('image-to-pdf', 'Error: ' + error.message, 'error');
      } finally {
        hideSpinner('image-to-pdf');
      }
    }

    async function convertImageToJpeg(file) {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = function(event) {
          const img = new Image();
          img.onload = function() {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            
            canvas.toBlob((blob) => {
              // Ensure the blob is not null before resolving
              if (blob) {
                resolve(new File([blob], file.name.replace(/\.[^/.]+$/, '.jpg'), { type: 'image/jpeg' }));
              } else {
                resolve(null); // Resolve with null if blob creation failed
              }
            }, 'image/jpeg', 0.9);
          };
          img.onerror = () => { // Handle image loading errors
            console.error(`Failed to load image: ${file.name}`);
            resolve(null);
          };
          img.src = event.target.result;
        };
        reader.onerror = () => { // Handle file reading errors
          console.error(`Failed to read file: ${file.name}`);
          resolve(null);
        };
        reader.readAsDataURL(file);
      });
    }

    async function convertTextToPDF() {
        const textContent = document.getElementById('text-content').value;
        const filename = document.getElementById('text-filename').value || 'document';
        
        if (!textContent.trim()) {
            showStatus('text-converter', 'Please enter some text to convert', 'error');
            return;
        }

        showStatus('text-converter', 'Converting text to PDF...', 'processing');
        showSpinner('text-converter');
        
        try {
            const { PDFDocument, rgb, StandardFonts } = PDFLib;
            const pdfDoc = await PDFDocument.create();
            
            // Embed a standard font. Helvetica is generally good, but ensure proper handling of newlines.
            const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
            
            const fontSize = 12;
            const lineHeight = fontSize * 1.2;
            const textMargin = 50;
            
            // Replace common newline characters with '\n' (which pdf-lib can then break if specified)
            // or specifically '\r' which is often handled as a line break by PDF viewers.
            // For simple text layout, '\n' should work with drawText's maxWidth and wordBreaks: [' ']
            // The original error "WinAnsi cannot encode " " (0x000a)" specifically refers to line feed (LF)
            // characters (0x000A). Let's explicitly replace them to ensure proper encoding and layout.
            let normalizedText = textContent.replace(/\r\n|\r/g, '\n'); // Normalize all newlines to LF
            
            // To prevent the WinAnsi encoding error, we need to manually break lines
            // and draw them one by one, ensuring no problematic characters pass directly to drawText
            // without proper context. Alternatively, use a font that natively supports more Unicode.
            // However, with standard fonts, manual line breaking is safer for complex text.

            const pages = [];
            let currentPage = pdfDoc.addPage();
            pages.push(currentPage);

            let yPosition = currentPage.getHeight() - textMargin;
            
            // Splitting the text by lines and then by words to fit within page width
            const rawLines = normalizedText.split('\n');
            for (const rawLine of rawLines) {
                let currentLineBuffer = '';
                const words = rawLine.split(' ');
                
                for (const word of words) {
                    const testLine = currentLineBuffer === '' ? word : `${currentLineBuffer} ${word}`;
                    const textWidth = helveticaFont.widthOfTextAtSize(testLine, fontSize);
                    const availableWidth = currentPage.getWidth() - (2 * textMargin);

                    if (textWidth > availableWidth && currentLineBuffer !== '') {
                        // Draw the buffered line
                        if (yPosition < textMargin) {
                            currentPage = pdfDoc.addPage();
                            pages.push(currentPage);
                            yPosition = currentPage.getHeight() - textMargin;
                        }
                        currentPage.drawText(currentLineBuffer, {
                            x: textMargin,
                            y: yPosition,
                            size: fontSize,
                            font: helveticaFont,
                            color: rgb(0, 0, 0),
                        });
                        yPosition -= lineHeight;
                        currentLineBuffer = word; // Start new buffer with current word
                    } else {
                        currentLineBuffer = testLine;
                    }
                }
                // Draw any remaining text in the buffer for the current line
                if (currentLineBuffer.length > 0) {
                    if (yPosition < textMargin) {
                        currentPage = pdfDoc.addPage();
                        pages.push(currentPage);
                        yPosition = currentPage.getHeight() - textMargin;
                    }
                    currentPage.drawText(currentLineBuffer, {
                        x: textMargin,
                        y: yPosition,
                        size: fontSize,
                        font: helveticaFont,
                        color: rgb(0, 0, 0),
                    });
                    yPosition -= lineHeight;
                }
            }

            // If no text was drawn (e.g., input was just spaces/newlines), ensure at least one page exists
            if (pdfDoc.getPageCount() === 0) {
              pdfDoc.addPage();
            }
            
            const pdfBytes = await pdfDoc.save();
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            saveAs(blob, `${filename}.pdf`);
            showStatus('text-converter', 'PDF created successfully!', 'success');
        } catch (error) {
            console.error('Error converting text to PDF:', error);
            showStatus('text-converter', 'Error: ' + error.message + '. Ensure text contains only supported characters.', 'error');
        } finally {
            hideSpinner('text-converter');
        }
    }


    async function convertPDFToWord() {
      const fileInput = document.getElementById('pdf-to-word-file');
      const format = document.getElementById('word-format').value;
      
      if (!fileInput.files || fileInput.files.length === 0) {
        showStatus('pdf-to-word', 'Please select a PDF file to convert', 'error');
        return;
      }

      showStatus('pdf-to-word', 'Extracting text from PDF...', 'processing');
      showSpinner('pdf-to-word');
      
      try {
        const file = fileInput.files[0];
        const fileReader = new FileReader();

        const fullTextPromise = new Promise((resolve, reject) => {
          fileReader.onload = async function() {
            try {
              const pdf = await pdfjsLib.getDocument({ data: new Uint8Array(fileReader.result) }).promise;
              let extractedText = '';
              for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                extractedText += textContent.items.map(item => item.str).join(' ') + '\n\n';
              }
              resolve(extractedText);
            } catch (error) {
              reject(error);
            }
          };
          fileReader.onerror = (error) => reject(error);
          fileReader.readAsArrayBuffer(file);
        });

        const fullText = await fullTextPromise;

        // Create a Word document
        const { Document, Paragraph, TextRun, Packer } = docx;
        
        const doc = new Document({
          sections: [{
            properties: {},
            children: [
              new Paragraph({
                children: [
                  new TextRun({
                    text: fullText,
                    size: 24 // Font size 12pt (24 half-points)
                  })
                ]
              })
            ]
          }]
        });
        
        let mimeType, extension;
        if (format === 'rtf') {
          mimeType = 'application/rtf';
          extension = 'rtf';
          // Basic RTF conversion: will lose all formatting, images, etc.
          // For actual RTF rich text, you need a full RTF generator, not just text replacement.
          const rtfContent = `{\\rtf1\\ansi\\ansicpg1252\\deff0\\deflang1033{\\fonttbl{\\f0\\fnil\\fcharset0 Calibri;}}\\viewkind4\\uc1\\pard\\f0\\fs24 ${fullText.replace(/\n/g, '\\par ')}\\par}`;
          const blob = new Blob([rtfContent], { type: mimeType });
          saveAs(blob, `converted-document.${extension}`);
        } else { // docx
          mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
          extension = 'docx';
          const blob = await Packer.toBlob(doc);
          saveAs(blob, `converted-document.${extension}`);
        }
        
        showStatus('pdf-to-word', 'PDF converted to Word successfully (text only)!', 'success');
        
        setTimeout(() => resetTool('pdf-to-word'), 2000);
      } catch (error) {
        console.error('Error converting PDF to Word:', error);
        showStatus('pdf-to-word', 'Error converting PDF to Word: ' + error.message + '. Complex PDF layouts may lose formatting.', 'error');
      } finally {
        hideSpinner('pdf-to-word');
      }
    }

    async function signPDF() {
      const fileInput = document.getElementById('pdf-signer-file');
      const pageNum = parseInt(document.getElementById('signature-page').value) || 1;
      const position = document.getElementById('signature-position').value;
      const sizeOption = document.getElementById('signature-size').value;
      const customWidth = parseInt(document.getElementById('custom-width').value) || 150;
      
      if (!fileInput.files || fileInput.files.length === 0) {
        showStatus('pdf-signer', 'Please select a PDF file to sign', 'error');
        return;
      }
      
      if (!signatureImage) {
        showStatus('pdf-signer', 'Please create and save your signature first', 'error');
        return;
      }

      showStatus('pdf-signer', 'Signing PDF...', 'processing');
      showSpinner('pdf-signer');
      
      try {
        const { PDFDocument } = PDFLib;
        const file = fileInput.files[0];
        const fileBuffer = await file.arrayBuffer();
        const pdfDoc = await PDFDocument.load(fileBuffer);
        
        // Convert signature image to PDF image
        const signatureImg = await pdfDoc.embedPng(signatureImage);
        
        // Get the page to sign (0-based index)
        const pageCount = pdfDoc.getPageCount();
        const pageIndex = Math.min(Math.max(0, pageNum - 1), pageCount - 1); // Ensure index is within bounds

        if (pageCount === 0) {
          showStatus('pdf-signer', 'The selected PDF has no pages to sign.', 'error');
          return;
        }

        const page = pdfDoc.getPage(pageIndex);
        
        // Calculate signature dimensions
        const { width, height } = page.getSize();
        let sigWidth;
        
        // Determine signature size based on selection
        switch(sizeOption) {
          case 'small':
            sigWidth = 100;
            break;
          case 'large':
            sigWidth = 200;
            break;
          case 'custom':
            sigWidth = customWidth;
            break;
          default: // medium
            sigWidth = 150;
        }
        
        const sigHeight = (signatureImg.height / signatureImg.width) * sigWidth;
        
        // Calculate signature position
        let x, y;
        const padding = 20;
        
        switch(position) {
          case 'bottom-left':
            x = padding;
            y = padding;
            break;
          case 'top-right':
            x = width - sigWidth - padding;
            y = height - sigHeight - padding;
            break;
          case 'top-left':
            x = padding;
            y = height - sigHeight - padding;
            break;
          case 'center':
            x = (width - sigWidth) / 2;
            y = (height - sigHeight) / 2;
            break;
          default: // bottom-right
            x = width - sigWidth - padding;
            y = padding;
        }
        
        // Draw the signature
        page.drawImage(signatureImg, {
          x,
          y,
          width: sigWidth,
          height: sigHeight,
        });
        
        // Save signed PDF
        const pdfBytes = await pdfDoc.save();
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        
        // Download the file
        saveAs(blob, 'signed-document.pdf');
        showStatus('pdf-signer', 'PDF signed successfully!', 'success');
        
        setTimeout(() => resetTool('pdf-signer'), 2000);
      } catch (error) {
        console.error('Error signing PDF:', error);
        showStatus('pdf-signer', 'Error: ' + error.message, 'error');
      } finally {
        hideSpinner('pdf-signer');
      }
    }

    // Enhanced image compression using browser-image-compression
    async function compressImages() {
      const fileInput = document.getElementById('compress-image-files');
      const quality = document.getElementById('image-quality').value / 100;
      const maxWidth = document.getElementById('image-resize').value;
      const outputFormat = document.getElementById('output-format').value;
      const compressionMode = document.getElementById('advanced-compression').value;
      
      if (!fileInput.files || fileInput.files.length === 0) {
        showStatus('compress-image', 'Please select at least one image to compress', 'error');
        return;
      }

      showStatus('compress-image', 'Compressing images...', 'processing');
      showSpinner('compress-image');
      
      try {
        const zip = new JSZip();
        let imgCount = 0;
        let compressedImgCount = 0;
        let totalOriginalSize = 0;
        let totalCompressedSize = 0;

        // Enhanced compression options based on mode
        const baseOptions = {
          maxSizeMB: 1, // Target size in MB for each image
          maxWidthOrHeight: maxWidth ? parseInt(maxWidth) : undefined,
          useWebWorker: true,
          initialQuality: quality,
          maxIteration: 10,
          preserveExif: true // Keep EXIF data
        };

        // Adjust options based on compression mode
        let options;
        if (compressionMode === 'aggressive') {
          options = {
            ...baseOptions,
            maxIteration: 15, // More iterations for smaller size
            quality: Math.max(0.1, quality * 0.8), // More aggressive quality reduction
            fileType: outputFormat === 'original' ? undefined : `image/${outputFormat}` // Correct MIME type
          };
        } else if (compressionMode === 'conservative') {
          options = {
            ...baseOptions,
            maxIteration: 5, // Fewer iterations for better quality
            quality: Math.min(1, quality * 1.1), // Slightly better quality
            fileType: outputFormat === 'original' ? undefined : `image/${outputFormat}` // Correct MIME type
          };
        } else {
          // Balanced mode
          options = {
            ...baseOptions,
            quality: quality,
            fileType: outputFormat === 'original' ? undefined : `image/${outputFormat}` // Correct MIME type
          };
        }

        // Process each image with enhanced compression
        for (let i = 0; i < fileInput.files.length; i++) {
          const file = fileInput.files[i];
          if (!file.type.match('image.*')) {
            console.warn(`Skipping non-image file: ${file.name}`);
            continue;
          }

          totalOriginalSize += file.size;

          try {
            const compressedFile = await browserImageCompression(file, options);
            totalCompressedSize += compressedFile.size;
            compressedImgCount++;
            
            // Generate filename with appropriate extension
            let filename = file.name;
            if (outputFormat !== 'original') {
              const nameWithoutExt = file.name.replace(/\.[^/.]+$/, '');
              const ext = outputFormat === 'jpeg' ? 'jpg' : outputFormat;
              filename = `${nameWithoutExt}.${ext}`;
            }
            
            zip.file(`compressed_${filename}`, compressedFile);
            imgCount++;
          } catch (error) {
            console.error(`Error compressing ${file.name}:`, error);
            // Fallback to original file if compression fails
            zip.file(`original_${file.name}`, file);
            imgCount++;
            showStatus('compress-image', `Error compressing ${file.name}. Adding original to zip.`, 'error');
          }
        }

        if (imgCount === 0) {
          showStatus('compress-image', 'No valid images found for compression.', 'error');
          return;
        }

        // Generate ZIP with better compression
        const zipContent = await zip.generateAsync({
          type: 'blob',
          compression: 'DEFLATE',
          compressionOptions: { level: 6 }
        });

        saveAs(zipContent, 'compressed_images.zip');
        
        // Calculate overall compression ratio
        let compressionMessage = '';
        if (totalOriginalSize > 0) {
          const compressionRatio = ((totalOriginalSize - totalCompressedSize) / totalOriginalSize * 100).toFixed(1);
          compressionMessage = `Overall size reduced by ${compressionRatio}%`;
        }
        
        if (compressedImgCount === imgCount) {
          showStatus('compress-image', `${imgCount} images compressed successfully! ${compressionMessage}`, 'success');
        } else {
          showStatus('compress-image', `Finished processing ${imgCount} images. ${compressedImgCount} were compressed, ${imgCount - compressedImgCount} were added as originals. ${compressionMessage}`, 'success');
        }
        
        setTimeout(() => resetTool('compress-image'), 2000);
      } catch (error) {
        console.error('Error compressing images:', error);
        showStatus('compress-image', 'Error: ' + error.message, 'error');
      } finally {
        hideSpinner('compress-image');
      }
    }

    // Enhanced QR Code generation with styling
    function generateQRCode() {
      const content = document.getElementById('qr-content').value;
      const size = parseInt(document.getElementById('qr-size').value);
      const color = document.getElementById('qr-color').value;
      const bgColor = document.getElementById('qr-bg-color').value;
      const dotType = document.getElementById('qr-dot-type').value;
      const cornerType = document.getElementById('qr-corner-type').value;
      
      if (!content) {
        showStatus('qr-code', 'Please enter content for the QR code', 'error');
        // Clear previous QR code if content is empty
        document.getElementById('qr-preview').innerHTML = '';
        document.getElementById('download-qr-btn').style.display = 'none';
        return;
      }
      
      const preview = document.getElementById('qr-preview');
      preview.innerHTML = '';
      
      // Create QR code with advanced styling
      const qrCode = new QRCodeStyling({
        width: size,
        height: size,
        type: "canvas",
        data: content,
        dotsOptions: {
          color: color,
          type: dotType
        },
        cornersSquareOptions: {
          color: color,
          type: cornerType
        },
        cornersDotOptions: {
          color: color,
          type: "dot"
        },
        backgroundOptions: {
          color: bgColor,
        }
      });
      
      qrCode.append(preview);
      
      // Store QR code instance for download
      window.currentQRCode = qrCode;
      
      document.getElementById('download-qr-btn').style.display = 'block';
      showStatus('qr-code', 'QR code generated successfully!', 'success');
    }

    function generateQRCodePreview() {
      const content = document.getElementById('qr-content').value;
      // Only generate if there's content to avoid errors or empty previews
      if (content.trim()) {
        generateQRCode();
      } else {
        document.getElementById('qr-preview').innerHTML = ''; // Clear preview if no content
        document.getElementById('download-qr-btn').style.display = 'none'; // Hide download button
        showStatus('qr-code', '', ''); // Clear status
      }
    }

    function downloadQRCode() {
      if (window.currentQRCode) {
        window.currentQRCode.download({ name: "qrcode", extension: "png" });
        
        // Reset tool after download
        setTimeout(() => resetTool('qr-code'), 2000); // resetTool now handles clearing status
      }
    }

    // Helper functions
    function showStatus(toolId, message, type) {
      const statusElement = document.getElementById(`${toolId}-status`);
      if (!statusElement) return;
      
      statusElement.textContent = message;
      statusElement.className = 'status-message';
      
      if (type === 'processing') {
        statusElement.classList.add('processing');
      } else if (type) {
        statusElement.classList.add(type);
      }
    }

    function showSpinner(toolId) {
      const spinner = document.getElementById(`${toolId}-spinner`);
      if (spinner) spinner.style.display = 'block';
    }

    function hideSpinner(toolId) {
      const spinner = document.getElementById(`${toolId}-spinner`);
      if (spinner) spinner.style.display = 'none';
    }

    // Debounce function for live preview
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Dynamically load JS if missing (currently not used but kept)
    function loadScript(src) {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }
  </script>
</body>
</html>